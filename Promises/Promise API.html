<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Promises/Promise API">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Promise API | Articles by Anant Trivedi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://theananttrivedi.github.io/anantblog/Promises/Promise API"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Promise API | Articles by Anant Trivedi"><meta data-rh="true" name="description" content="There are 6 static methods in the Promise class. We’ll quickly cover their use cases here."><meta data-rh="true" property="og:description" content="There are 6 static methods in the Promise class. We’ll quickly cover their use cases here."><link data-rh="true" rel="icon" href="/anantblog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://theananttrivedi.github.io/anantblog/Promises/Promise API"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Promise API" hreflang="en"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Promise API" hreflang="x-default"><link rel="stylesheet" href="/anantblog/assets/css/styles.dd6252f0.css">
<link rel="preload" href="/anantblog/assets/js/runtime~main.424d7a41.js" as="script">
<link rel="preload" href="/anantblog/assets/js/main.6729f170.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/anantblog/"><b class="navbar__title text--truncate">Blog</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/anantblog/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/javascript">Javascript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Javascript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/modules">Modules</a><button aria-label="Toggle the collapsible sidebar category &#x27;Modules&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/anantblog/category/promises">Promises</a><button aria-label="Toggle the collapsible sidebar category &#x27;Promises&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Async await">Async await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Callbacks">Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Error Handling with Promises">Error Handling with Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Microtasks">Microtasks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/anantblog/Promises/Promise API">Promise API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise Chaining">Promise Chaining</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises">Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promisifying">Promisifying</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/code-snippets">Code Snippets</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code Snippets&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/anantblog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/anantblog/category/promises"><span itemprop="name">Promises</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Promise API</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>Promise API</h1></header><p>There are 6 static methods in the Promise class. We’ll quickly cover their use cases here.</p><p>Promise.all
Let’s say we want many promises to execute in parallel and wait until all of them are ready.</p><p>For instance, download several URLs in parallel and process the content once they are all done.</p><p>That’s what Promise.all is for.</p><p>The syntax is:</p><p>let promise = Promise.all(iterable);
Promise.all takes an iterable (usually, an array of promises) and returns a new promise.</p><p>The new promise resolves when all listed promises are resolved, and the array of their results becomes its result.</p><p>For instance, the Promise.all below settles after 3 seconds, and then its result is an array <!-- -->[1, 2, 3]<!-- -->:</p><p>Promise.all(<!-- -->[
new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1
new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2
new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000))  // 3
]<!-- -->).then(alert); // 1,2,3 when promises are ready: each promise contributes an array member
Please note that the order of the resulting array members is the same as in its source promises. Even though the first promise takes the longest time to resolve, it’s still first in the array of results.</p><p>A common trick is to map an array of job data into an array of promises, and then wrap that into Promise.all.</p><p>For instance, if we have an array of URLs, we can fetch them all like this:</p><p>let urls = <!-- -->[
&#x27;https://api.github.com/users/iliakan&#x27;,
&#x27;https://api.github.com/users/remy&#x27;,
&#x27;https://api.github.com/users/jeresig&#x27;
]<!-- -->;</p><p>// map every url to the promise of the fetch
let requests = urls.map(url =&gt; fetch(url));</p><p>// Promise.all waits until all jobs are resolved
Promise.all(requests)
.then(responses =&gt; responses.forEach(
response =&gt; alert(<code>${response.url}: ${response.status}</code>)
));
A bigger example with fetching user information for an array of GitHub users by their names (we could fetch an array of goods by their ids, the logic is identical):</p><p>let names = <!-- -->[&#x27;iliakan&#x27;, &#x27;remy&#x27;, &#x27;jeresig&#x27;]<!-- -->;</p><p>let requests = names.map(name =&gt; fetch(<code>https://api.github.com/users/${name}</code>));</p><p>Promise.all(requests)
.then(responses =&gt; {
// all responses are resolved successfully
for(let response of responses) {
alert(<code>${response.url}: ${response.status}</code>); // shows 200 for every url
}</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return responses;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  })
// map array of responses into an array of response.json() to read their content
.then(responses =&gt; Promise.all(responses.map(r =&gt; r.json())))
// all JSON answers are parsed: &quot;users&quot; is the array of them
.then(users =&gt; users.forEach(user =&gt; alert(user.name)));
If any of the promises is rejected, the promise returned by Promise.all immediately rejects with that error.</p><p>For instance:</p><p>Promise.all(<!-- -->[
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 2000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))
]<!-- -->).catch(alert); // Error: Whoops!
Here the second promise rejects in two seconds. That leads to an immediate rejection of Promise.all, so .catch executes: the rejection error becomes the outcome of the entire Promise.all.</p><p>In case of an error, other promises are ignored
If one promise rejects, Promise.all immediately rejects, completely forgetting about the other ones in the list. Their results are ignored.</p><p>For example, if there are multiple fetch calls, like in the example above, and one fails, the others will still continue to execute, but Promise.all won’t watch them anymore. They will probably settle, but their results will be ignored.</p><p>Promise.all does nothing to cancel them, as there’s no concept of “cancellation” in promises. In another chapter we’ll cover AbortController that can help with that, but it’s not a part of the Promise API.</p><p>Promise.all(iterable) allows non-promise “regular” values in iterable
Normally, Promise.all(...) accepts an iterable (in most cases an array) of promises. But if any of those objects is not a promise, it’s passed to the resulting array “as is”.</p><p>For instance, here the results are <!-- -->[1, 2, 3]<!-- -->:</p><p>Promise.all(<!-- -->[
new Promise((resolve, reject) =&gt; {
setTimeout(() =&gt; resolve(1), 1000)
}),
2,
3
]<!-- -->).then(alert); // 1, 2, 3
So we are able to pass ready values to Promise.all where convenient.</p><p>Promise.allSettled
A recent addition
This is a recent addition to the language. Old browsers may need polyfills.
Promise.all rejects as a whole if any promise rejects. That’s good for “all or nothing” cases, when we need all results successful to proceed:</p><p>Promise.all(<!-- -->[
fetch(&#x27;/template.html&#x27;),
fetch(&#x27;/style.css&#x27;),
fetch(&#x27;/data.json&#x27;)
]<!-- -->).then(render); // render method needs results of all fetches
Promise.allSettled just waits for all promises to settle, regardless of the result. The resulting array has:</p><p>{status:&quot;fulfilled&quot;, value:result} for successful responses,
{status:&quot;rejected&quot;, reason:error} for errors.
For example, we’d like to fetch the information about multiple users. Even if one request fails, we’re still interested in the others.</p><p>Let’s use Promise.allSettled:</p><p>let urls = <!-- -->[
&#x27;https://api.github.com/users/iliakan&#x27;,
&#x27;https://api.github.com/users/remy&#x27;,
&#x27;https://no-such-url&#x27;
]<!-- -->;</p><p>Promise.allSettled(urls.map(url =&gt; fetch(url)))
.then(results =&gt; { // (<em>)
results.forEach((result, num) =&gt; {
if (result.status == &quot;fulfilled&quot;) {
alert(<code>${urls[num]}: ${result.value.status}</code>);
}
if (result.status == &quot;rejected&quot;) {
alert(<code>${urls[num]}: ${result.reason}</code>);
}
});
});
The results in the line (</em>) above will be:</p><p>[
{status: &#x27;fulfilled&#x27;, value: ...response...},
{status: &#x27;fulfilled&#x27;, value: ...response...},
{status: &#x27;rejected&#x27;, reason: ...error object...}
]<!-- -->
So for each promise we get its status and value/error.</p><p>Polyfill
If the browser doesn’t support Promise.allSettled, it’s easy to polyfill:</p><p>if (!Promise.allSettled) {
const rejectHandler = reason =&gt; ({ status: &#x27;rejected&#x27;, reason });</p><p>  const resolveHandler = value =&gt; ({ status: &#x27;fulfilled&#x27;, value });</p><p>  Promise.allSettled = function (promises) {
const convertedPromises = promises.map(p =&gt; Promise.resolve(p).then(resolveHandler, rejectHandler));
return Promise.all(convertedPromises);
};
}
In this code, promises.map takes input values, turns them into promises (just in case a non-promise was passed) with p =&gt; Promise.resolve(p), and then adds .then handler to every one.</p><p>That handler turns a successful result value into {status:&#x27;fulfilled&#x27;, value}, and an error reason into {status:&#x27;rejected&#x27;, reason}. That’s exactly the format of Promise.allSettled.</p><p>Now we can use Promise.allSettled to get the results of all given promises, even if some of them reject.</p><p>Promise.race
Similar to Promise.all, but waits only for the first settled promise and gets its result (or error).</p><p>The syntax is:</p><p>let promise = Promise.race(iterable);
For instance, here the result will be 1:</p><p>Promise.race(<!-- -->[
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 2000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))
]<!-- -->).then(alert); // 1
The first promise here was fastest, so it became the result. After the first settled promise “wins the race”, all further results/errors are ignored.</p><p>Promise.any
Similar to Promise.race, but waits only for the first fulfilled promise and gets its result. If all of the given promises are rejected, then the returned promise is rejected with AggregateError – a special error object that stores all promise errors in its errors property.</p><p>The syntax is:
let promise = Promise.any(iterable);
For instance, here the result will be 1:</p><p>Promise.any(<!-- -->[
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 1000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 2000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))
]<!-- -->).then(alert); // 1
The first promise here was fastest, but it was rejected, so the second promise became the result. After the first fulfilled promise “wins the race”, all further results are ignored.</p><p>Here’s an example when all promises fail:</p><p>Promise.any(<!-- -->[
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Ouch!&quot;)), 1000)),
new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Error!&quot;)), 2000))
]<!-- -->).catch(error =&gt; {
console.log(error.constructor.name); // AggregateError
console.log(error.errors<!-- -->[0]<!-- -->); // Error: Ouch!
console.log(error.errors<!-- -->[1]<!-- -->); // Error: Error!
});
As you can see, error objects for failed promises are available in the errors property of the AggregateError object.</p><p>Promise.resolve/reject
Methods Promise.resolve and Promise.reject are rarely needed in modern code, because async/await syntax (we’ll cover it a bit later) makes them somewhat obsolete.</p><p>We cover them here for completeness and for those who can’t use async/await for some reason.</p><p>Promise.resolve
Promise.resolve(value) creates a resolved promise with the result value.</p><p>Same as:</p><p>let promise = new Promise(resolve =&gt; resolve(value));
The method is used for compatibility, when a function is expected to return a promise.</p><p>For example, the loadCached function below fetches a URL and remembers (caches) its content. For future calls with the same URL it immediately gets the previous content from cache, but uses Promise.resolve to make a promise of it, so the returned value is always a promise:</p><p>let cache = new Map();</p><p>function loadCached(url) {
if (cache.has(url)) {
return Promise.resolve(cache.get(url)); // (*)
}</p><p>  return fetch(url)
.then(response =&gt; response.text())
.then(text =&gt; {
cache.set(url,text);
return text;
});
}
We can write loadCached(url).then(…), because the function is guaranteed to return a promise. We can always use .then after loadCached. That’s the purpose of Promise.resolve in the line (*).</p><p>Promise.reject
Promise.reject(error) creates a rejected promise with error.</p><p>Same as:</p><p>let promise = new Promise((resolve, reject) =&gt; reject(error));
In practice, this method is almost never used.</p><p>Summary
There are 6 static methods of Promise class:</p><p>Promise.all(promises) – waits for all promises to resolve and returns an array of their results. If any of the given promises rejects, it becomes the error of Promise.all, and all other results are ignored.
Promise.allSettled(promises) (recently added method) – waits for all promises to settle and returns their results as an array of objects with:
status: &quot;fulfilled&quot; or &quot;rejected&quot;
value (if fulfilled) or reason (if rejected).
Promise.race(promises) – waits for the first promise to settle, and its result/error becomes the outcome.
Promise.any(promises) (recently added method) – waits for the first promise to fulfill, and its result becomes the outcome. If all of the given promises are rejected, AggregateError becomes the error of Promise.any.
Promise.resolve(value) – makes a resolved promise with the given value.
Promise.reject(error) – makes a rejected promise with the given error.
Of all these, Promise.all is probably the most common in practice.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/anantblog/Promises/Microtasks"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Microtasks</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/anantblog/Promises/Promise Chaining"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Promise Chaining</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022</div></div></div></footer></div>
<script src="/anantblog/assets/js/runtime~main.424d7a41.js"></script>
<script src="/anantblog/assets/js/main.6729f170.js"></script>
</body>
</html>