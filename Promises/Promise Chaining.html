<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Promises/Promise Chaining">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Promise Chaining | Articles by Anant Trivedi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://theananttrivedi.github.io/anantblog/Promises/Promise Chaining"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Promise Chaining | Articles by Anant Trivedi"><meta data-rh="true" name="description" content="Let’s return to the problem mentioned in the chapter Introduction we have a sequence of asynchronous tasks to be performed one after another — for instance, loading scripts. How can we code it well?"><meta data-rh="true" property="og:description" content="Let’s return to the problem mentioned in the chapter Introduction we have a sequence of asynchronous tasks to be performed one after another — for instance, loading scripts. How can we code it well?"><link data-rh="true" rel="icon" href="/anantblog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://theananttrivedi.github.io/anantblog/Promises/Promise Chaining"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Promise Chaining" hreflang="en"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Promise Chaining" hreflang="x-default"><link rel="stylesheet" href="/anantblog/assets/css/styles.dd6252f0.css">
<link rel="preload" href="/anantblog/assets/js/runtime~main.424d7a41.js" as="script">
<link rel="preload" href="/anantblog/assets/js/main.6729f170.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/anantblog/"><b class="navbar__title text--truncate">Blog</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/anantblog/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/javascript">Javascript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Javascript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/modules">Modules</a><button aria-label="Toggle the collapsible sidebar category &#x27;Modules&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/anantblog/category/promises">Promises</a><button aria-label="Toggle the collapsible sidebar category &#x27;Promises&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Async await">Async await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Callbacks">Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Error Handling with Promises">Error Handling with Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Microtasks">Microtasks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise API">Promise API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/anantblog/Promises/Promise Chaining">Promise Chaining</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises">Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promisifying">Promisifying</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/code-snippets">Code Snippets</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code Snippets&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/anantblog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/anantblog/category/promises"><span itemprop="name">Promises</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Promise Chaining</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>Promise Chaining</h1></header><p>Let’s return to the problem mentioned in the chapter Introduction: callbacks: we have a sequence of asynchronous tasks to be performed one after another — for instance, loading scripts. How can we code it well?</p><p>Promises provide a couple of recipes to do that.</p><p>In this chapter we cover promise chaining.</p><p>It looks like this:</p><p>new Promise(function(resolve, reject) {</p><p>  setTimeout(() =&gt; resolve(1), 1000); // (*)</p><p>}).then(function(result) { // (**)</p><p>  alert(result); // 1
return result * 2;</p><p>}).then(function(result) { // (***)</p><p>  alert(result); // 2
return result * 2;</p><p>}).then(function(result) {</p><p>  alert(result); // 4
return result * 2;</p><p>});
The idea is that the result is passed through the chain of .then handlers.</p><p>Here the flow is:</p><p>The initial promise resolves in 1 second (*),
Then the .then handler is called (<strong>), which in turn creates a new promise (resolved with 2 value).
The next then (*</strong>) gets the result of the previous one, processes it (doubles) and passes it to the next handler.
…and so on.
As the result is passed along the chain of handlers, we can see a sequence of alert calls: 1 → 2 → 4.</p><p>The whole thing works, because every call to a .then returns a new promise, so that we can call the next .then on it.</p><p>When a handler returns a value, it becomes the result of that promise, so the next .then is called with it.</p><p>A classic newbie error: technically we can also add many .then to a single promise. This is not chaining.</p><p>For example:</p><p>let promise = new Promise(function(resolve, reject) {
setTimeout(() =&gt; resolve(1), 1000);
});</p><p>promise.then(function(result) {
alert(result); // 1
return result * 2;
});</p><p>promise.then(function(result) {
alert(result); // 1
return result * 2;
});</p><p>promise.then(function(result) {
alert(result); // 1
return result * 2;
});
What we did here is just several handlers to one promise. They don’t pass the result to each other; instead they process it independently.</p><p>Here’s the picture (compare it with the chaining above):</p><p>All .then on the same promise get the same result – the result of that promise. So in the code above all alert show the same: 1.</p><p>In practice we rarely need multiple handlers for one promise. Chaining is used much more often.</p><p>Returning promises
A handler, used in .then(handler) may create and return a promise.</p><p>In that case further handlers wait until it settles, and then get its result.</p><p>For instance:</p><p>new Promise(function(resolve, reject) {</p><p>  setTimeout(() =&gt; resolve(1), 1000);</p><p>}).then(function(result) {</p><p>  alert(result); // 1</p><p>  return new Promise((resolve, reject) =&gt; { // (<em>)
setTimeout(() =&gt; resolve(result </em> 2), 1000);
});</p><p>}).then(function(result) { // (**)</p><p>  alert(result); // 2</p><p>  return new Promise((resolve, reject) =&gt; {
setTimeout(() =&gt; resolve(result * 2), 1000);
});</p><p>}).then(function(result) {</p><p>  alert(result); // 4</p><p>});
Here the first .then shows 1 and returns new Promise(…) in the line (<em>). After one second it resolves, and the result (the argument of resolve, here it’s result </em> 2) is passed on to the handler of the second .then. That handler is in the line (**), it shows 2 and does the same thing.</p><p>So the output is the same as in the previous example: 1 → 2 → 4, but now with 1 second delay between alert calls.</p><p>Returning promises allows us to build chains of asynchronous actions.</p><p>Example: loadScript
Let’s use this feature with the promisified loadScript, defined in the previous chapter, to load scripts one by one, in sequence:</p><p>loadScript(&quot;/article/promise-chaining/one.js&quot;)
.then(function(script) {
return loadScript(&quot;/article/promise-chaining/two.js&quot;);
})
.then(function(script) {
return loadScript(&quot;/article/promise-chaining/three.js&quot;);
})
.then(function(script) {
// use functions declared in scripts
// to show that they indeed loaded
one();
two();
three();
});
This code can be made bit shorter with arrow functions:</p><p>loadScript(&quot;/article/promise-chaining/one.js&quot;)
.then(script =&gt; loadScript(&quot;/article/promise-chaining/two.js&quot;))
.then(script =&gt; loadScript(&quot;/article/promise-chaining/three.js&quot;))
.then(script =&gt; {
// scripts are loaded, we can use functions declared there
one();
two();
three();
});
Here each loadScript call returns a promise, and the next .then runs when it resolves. Then it initiates the loading of the next script. So scripts are loaded one after another.</p><p>We can add more asynchronous actions to the chain. Please note that the code is still “flat” — it grows down, not to the right. There are no signs of the “pyramid of doom”.</p><p>Technically, we could add .then directly to each loadScript, like this:</p><p>loadScript(&quot;/article/promise-chaining/one.js&quot;).then(script1 =&gt; {
loadScript(&quot;/article/promise-chaining/two.js&quot;).then(script2 =&gt; {
loadScript(&quot;/article/promise-chaining/three.js&quot;).then(script3 =&gt; {
// this function has access to variables script1, script2 and script3
one();
two();
three();
});
});
});
This code does the same: loads 3 scripts in sequence. But it “grows to the right”. So we have the same problem as with callbacks.</p><p>People who start to use promises sometimes don’t know about chaining, so they write it this way. Generally, chaining is preferred.</p><p>Sometimes it’s ok to write .then directly, because the nested function has access to the outer scope. In the example above the most nested callback has access to all variables script1, script2, script3. But that’s an exception rather than a rule.</p><p>Thenables
To be precise, a handler may return not exactly a promise, but a so-called “thenable” object – an arbitrary object that has a method .then. It will be treated the same way as a promise.</p><p>The idea is that 3rd-party libraries may implement “promise-compatible” objects of their own. They can have an extended set of methods, but also be compatible with native promises, because they implement .then.</p><p>Here’s an example of a thenable object:</p><p>class Thenable {
constructor(num) {
this.num = num;
}
then(resolve, reject){
alert(resolve); // function() { native code }
// resolve with this.num<em>2 after the 1 second
setTimeout(() =&gt; resolve(this.num </em> 2), 1000); // (**)
}
}</p><p>new Promise(resolve =&gt; resolve(1))
.then(result =&gt; {
return new Thenable(result); // (<em>)
})
.then(alert); // shows 2 after 1000ms
JavaScript checks the object returned by the .then handler in line (</em>): if it has a callable method named then, then it calls that method providing native functions resolve, reject as arguments (similar to an executor) and waits until one of them is called. In the example above resolve(2) is called after 1 second (**). Then the result is passed further down the chain.</p><p>This feature allows us to integrate custom objects with promise chains without having to inherit from Promise.</p><p>Bigger example: fetch
In frontend programming, promises are often used for network requests. So let’s see an extended example of that.</p><p>We’ll use the fetch method to load the information about the user from the remote server. It has a lot of optional parameters covered in separate chapters, but the basic syntax is quite simple:</p><p>let promise = fetch(url);
This makes a network request to the url and returns a promise. The promise resolves with a response object when the remote server responds with headers, but before the full response is downloaded.</p><p>To read the full response, we should call the method response.text(): it returns a promise that resolves when the full text is downloaded from the remote server, with that text as a result.</p><p>The code below makes a request to user.json and loads its text from the server:</p><p>fetch(&#x27;/article/promise-chaining/user.json&#x27;)
// .then below runs when the remote server responds
.then(function(response) {
// response.text() returns a new promise that resolves with the full response text
// when it loads
return response.text();
})
.then(function(text) {
// ...and here&#x27;s the content of the remote file
alert(text); // {&quot;name&quot;: &quot;iliakan&quot;, &quot;isAdmin&quot;: true}
});
The response object returned from fetch also includes the method response.json() that reads the remote data and parses it as JSON. In our case that’s even more convenient, so let’s switch to it.</p><p>We’ll also use arrow functions for brevity:</p><p>// same as above, but response.json() parses the remote content as JSON
fetch(&#x27;/article/promise-chaining/user.json&#x27;)
.then(response =&gt; response.json())
.then(user =&gt; alert(user.name)); // iliakan, got user name
Now let’s do something with the loaded user.</p><p>For instance, we can make one more request to GitHub, load the user profile and show the avatar:</p><p>// Make a request for user.json
fetch(&#x27;/article/promise-chaining/user.json&#x27;)
// Load it as json
.then(response =&gt; response.json())
// Make a request to GitHub
.then(user =&gt; fetch(<code>https://api.github.com/users/${user.name}</code>))
// Load the response as json
.then(response =&gt; response.json())
// Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)
.then(githubUser =&gt; {
let img = document.createElement(&#x27;img&#x27;);
img.src = githubUser.avatar_url;
img.className = &quot;promise-avatar-example&quot;;
document.body.append(img);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout(() =&gt; img.remove(), 3000); // (*)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  });
The code works; see comments about the details. However, there’s a potential problem in it, a typical error for those who begin to use promises.</p><p>Look at the line (*): how can we do something after the avatar has finished showing and gets removed? For instance, we’d like to show a form for editing that user or something else. As of now, there’s no way.</p><p>To make the chain extendable, we need to return a promise that resolves when the avatar finishes showing.</p><p>Like this:</p><p>fetch(&#x27;/article/promise-chaining/user.json&#x27;)
.then(response =&gt; response.json())
.then(user =&gt; fetch(<code>https://api.github.com/users/${user.name}</code>))
.then(response =&gt; response.json())
.then(githubUser =&gt; new Promise(function(resolve, reject) { // (*)
let img = document.createElement(&#x27;img&#x27;);
img.src = githubUser.avatar_url;
img.className = &quot;promise-avatar-example&quot;;
document.body.append(img);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  img.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve(githubUser); // (**)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, 3000);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  }))
// triggers after 3 seconds
.then(githubUser =&gt; alert(<code>Finished showing ${githubUser.name}</code>));
That is, the .then handler in line (*) now returns new Promise, that becomes settled only after the call of resolve(githubUser) in setTimeout (**). The next .then in the chain will wait for that.</p><p>As a good practice, an asynchronous action should always return a promise. That makes it possible to plan actions after it; even if we don’t plan to extend the chain now, we may need it later.</p><p>Finally, we can split the code into reusable functions:</p><p>function loadJson(url) {
return fetch(url)
.then(response =&gt; response.json());
}</p><p>function loadGithubUser(name) {
return loadJson(<code>https://api.github.com/users/${name}</code>);
}</p><p>function showAvatar(githubUser) {
return new Promise(function(resolve, reject) {
let img = document.createElement(&#x27;img&#x27;);
img.src = githubUser.avatar_url;
img.className = &quot;promise-avatar-example&quot;;
document.body.append(img);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  img.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve(githubUser);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, 3000);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  });
}</p><p>// Use them:
loadJson(&#x27;/article/promise-chaining/user.json&#x27;)
.then(user =&gt; loadGithubUser(user.name))
.then(showAvatar)
.then(githubUser =&gt; alert(<code>Finished showing ${githubUser.name}</code>));
// ...
Summary
If a .then (or catch/finally, doesn’t matter) handler returns a promise, the rest of the chain waits until it settles. When it does, its result (or error) is passed further.</p><p>Here’s a full picture:</p><p>Tasks
Promise: then versus catch
Are these code fragments equal? In other words, do they behave the same way in any circumstances, for any handler functions?</p><p>promise.then(f1).catch(f2);
Versus:</p><p>promise.then(f1, f2);
solution
The short answer is: no, they are not equal:</p><p>The difference is that if an error happens in f1, then it is handled by .catch here:</p><p>promise
.then(f1)
.catch(f2);
…But not here:</p><p>promise
.then(f1, f2);
That’s because an error is passed down the chain, and in the second code piece there’s no chain below f1.</p><p>In other words, .then passes results/errors to the next .then/catch. So in the first example, there’s a catch below, and in the second one there isn’t, so the error is unhandled.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/anantblog/Promises/Promise API"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Promise API</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/anantblog/Promises"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Promises</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022</div></div></div></footer></div>
<script src="/anantblog/assets/js/runtime~main.424d7a41.js"></script>
<script src="/anantblog/assets/js/main.6729f170.js"></script>
</body>
</html>