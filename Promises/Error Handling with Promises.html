<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Promises/Error Handling with Promises">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Error Handling with Promises | Articles by Anant Trivedi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://theananttrivedi.github.io/anantblog/Promises/Error Handling with Promises"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Error Handling with Promises | Articles by Anant Trivedi"><meta data-rh="true" name="description" content="Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice."><meta data-rh="true" property="og:description" content="Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice."><link data-rh="true" rel="icon" href="/anantblog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://theananttrivedi.github.io/anantblog/Promises/Error Handling with Promises"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Error Handling with Promises" hreflang="en"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Error Handling with Promises" hreflang="x-default"><link rel="stylesheet" href="/anantblog/assets/css/styles.dd6252f0.css">
<link rel="preload" href="/anantblog/assets/js/runtime~main.424d7a41.js" as="script">
<link rel="preload" href="/anantblog/assets/js/main.6729f170.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/anantblog/"><b class="navbar__title text--truncate">Blog</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/anantblog/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/javascript">Javascript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Javascript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/modules">Modules</a><button aria-label="Toggle the collapsible sidebar category &#x27;Modules&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/anantblog/category/promises">Promises</a><button aria-label="Toggle the collapsible sidebar category &#x27;Promises&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Async await">Async await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Callbacks">Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/anantblog/Promises/Error Handling with Promises">Error Handling with Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Microtasks">Microtasks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise API">Promise API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise Chaining">Promise Chaining</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises">Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promisifying">Promisifying</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/code-snippets">Code Snippets</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code Snippets&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/anantblog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/anantblog/category/promises"><span itemprop="name">Promises</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Error Handling with Promises</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>Error Handling with Promises</h1></header><p>Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice.</p><p>For instance, in the code below the URL to fetch is wrong (no such site) and .catch handles the error:</p><p>fetch(&#x27;<a href="https://no-such-server.blabla&#x27;" target="_blank" rel="noopener noreferrer">https://no-such-server.blabla&#x27;</a>) // rejects
.then(response =&gt; response.json())
.catch(err =&gt; alert(err)) // TypeError: failed to fetch (the text may vary)
As you can see, the .catch doesn’t have to be immediate. It may appear after one or maybe several .then.</p><p>Or, maybe, everything is all right with the site, but the response is not valid JSON. The easiest way to catch all errors is to append .catch to the end of chain:</p><p>fetch(&#x27;/article/promise-chaining/user.json&#x27;)
.then(response =&gt; response.json())
.then(user =&gt; fetch(<code>https://api.github.com/users/${user.name}</code>))
.then(response =&gt; response.json())
.then(githubUser =&gt; new Promise((resolve, reject) =&gt; {
let img = document.createElement(&#x27;img&#x27;);
img.src = githubUser.avatar_url;
img.className = &quot;promise-avatar-example&quot;;
document.body.append(img);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  img.remove();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve(githubUser);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, 3000);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  }))
.catch(error =&gt; alert(error.message));
Normally, such .catch doesn’t trigger at all. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.</p><p>Implicit try…catch
The code of a promise executor and promise handlers has an &quot;invisible try..catch&quot; around it. If an exception happens, it gets caught and treated as a rejection.</p><p>For instance, this code:</p><p>new Promise((resolve, reject) =&gt; {
throw new Error(&quot;Whoops!&quot;);
}).catch(alert); // Error: Whoops!
…Works exactly the same as this:</p><p>new Promise((resolve, reject) =&gt; {
reject(new Error(&quot;Whoops!&quot;));
}).catch(alert); // Error: Whoops!
The &quot;invisible try..catch&quot; around the executor automatically catches the error and turns it into rejected promise.</p><p>This happens not only in the executor function, but in its handlers as well. If we throw inside a .then handler, that means a rejected promise, so the control jumps to the nearest error handler.</p><p>Here’s an example:</p><p>new Promise((resolve, reject) =&gt; {
resolve(&quot;ok&quot;);
}).then((result) =&gt; {
throw new Error(&quot;Whoops!&quot;); // rejects the promise
}).catch(alert); // Error: Whoops!
This happens for all errors, not just those caused by the throw statement. For example, a programming error:</p><p>new Promise((resolve, reject) =&gt; {
resolve(&quot;ok&quot;);
}).then((result) =&gt; {
blabla(); // no such function
}).catch(alert); // ReferenceError: blabla is not defined
The final .catch not only catches explicit rejections, but also accidental errors in the handlers above.</p><p>Rethrowing
As we already noticed, .catch at the end of the chain is similar to try..catch. We may have as many .then handlers as we want, and then use a single .catch at the end to handle errors in all of them.</p><p>In a regular try..catch we can analyze the error and maybe rethrow it if it can’t be handled. The same thing is possible for promises.</p><p>If we throw inside .catch, then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful .then handler.</p><p>In the example below the .catch successfully handles the error:</p><p>// the execution: catch -&gt; then
new Promise((resolve, reject) =&gt; {</p><p>  throw new Error(&quot;Whoops!&quot;);</p><p>}).catch(function(error) {</p><p>  alert(&quot;The error is handled, continue normally&quot;);</p><p>}).then(() =&gt; alert(&quot;Next successful handler runs&quot;));
Here the .catch block finishes normally. So the next successful .then handler is called.</p><p>In the example below we see the other situation with .catch. The handler (*) catches the error and just can’t handle it (e.g. it only knows how to handle URIError), so it throws it again:</p><p>// the execution: catch -&gt; catch
new Promise((resolve, reject) =&gt; {</p><p>  throw new Error(&quot;Whoops!&quot;);</p><p>}).catch(function(error) { // (*)</p><p>  if (error instanceof URIError) {
// handle it
} else {
alert(&quot;Can&#x27;t handle such error&quot;);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">throw error; // throwing this or another error jumps to the next catch</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  }</p><p>}).then(function() {
/<em> doesn&#x27;t run here </em>/
}).catch(error =&gt; { // (**)</p><p>  alert(<code>The unknown error has occurred: ${error}</code>);
// don&#x27;t return anything =&gt; execution goes the normal way</p><p>});
The execution jumps from the first .catch (*) to the next one (**) down the chain.</p><p>Unhandled rejections
What happens when an error is not handled? For instance, we forgot to append .catch to the end of the chain, like here:</p><p>new Promise(function() {
noSuchFunction(); // Error here (no such function)
})
.then(() =&gt; {
// successful promise handlers, one or more
}); // without .catch at the end!
In case of an error, the promise becomes rejected, and the execution should jump to the closest rejection handler. But there is none. So the error gets “stuck”. There’s no code to handle it.</p><p>In practice, just like with regular unhandled errors in code, it means that something has gone terribly wrong.</p><p>What happens when a regular error occurs and is not caught by try..catch? The script dies with a message in the console. A similar thing happens with unhandled promise rejections.</p><p>The JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.</p><p>In the browser we can catch such errors using the event unhandledrejection:</p><p>window.addEventListener(&#x27;unhandledrejection&#x27;, function(event) {
// the event object has two special properties:
alert(event.promise); // <!-- -->[object Promise]<!-- --> - the promise that generated the error
alert(event.reason); // Error: Whoops! - the unhandled error object
});</p><p>new Promise(function() {
throw new Error(&quot;Whoops!&quot;);
}); // no catch to handle the error
The event is the part of the HTML standard.</p><p>If an error occurs, and there’s no .catch, the unhandledrejection handler triggers, and gets the event object with the information about the error, so we can do something.</p><p>Usually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.</p><p>In non-browser environments like Node.js there are other ways to track unhandled errors.</p><p>Summary
.catch handles errors in promises of all kinds: be it a reject() call, or an error thrown in a handler.
.then also catches errors in the same manner, if given the second argument (which is the error handler).
We should place .catch exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones (maybe they are programming mistakes).
It’s ok not to use .catch at all, if there’s no way to recover from an error.
In any case we should have the unhandledrejection event handler (for browsers, and analogs for other environments) to track unhandled errors and inform the user (and probably our server) about them, so that our app never “just dies”.
Tasks
Error in setTimeout
What do you think? Will the .catch trigger? Explain your answer.</p><p>new Promise(function(resolve, reject) {
setTimeout(() =&gt; {
throw new Error(&quot;Whoops!&quot;);
}, 1000);
}).catch(alert);
solution
The answer is: no, it won’t:</p><p>new Promise(function(resolve, reject) {
setTimeout(() =&gt; {
throw new Error(&quot;Whoops!&quot;);
}, 1000);
}).catch(alert);
As said in the chapter, there’s an &quot;implicit try..catch&quot; around the function code. So all synchronous errors are handled.</p><p>But here the error is generated not while the executor is running, but later. So the promise can’t handle it.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/anantblog/Promises/Callbacks"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Callbacks</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/anantblog/Promises/Microtasks"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Microtasks</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022</div></div></div></footer></div>
<script src="/anantblog/assets/js/runtime~main.424d7a41.js"></script>
<script src="/anantblog/assets/js/main.6729f170.js"></script>
</body>
</html>