<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Promises/Async await">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">Async await | Articles by Anant Trivedi</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://theananttrivedi.github.io/anantblog/Promises/Async await"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Async await | Articles by Anant Trivedi"><meta data-rh="true" name="description" content="There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use."><meta data-rh="true" property="og:description" content="There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use."><link data-rh="true" rel="icon" href="/anantblog/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://theananttrivedi.github.io/anantblog/Promises/Async await"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Async await" hreflang="en"><link data-rh="true" rel="alternate" href="https://theananttrivedi.github.io/anantblog/Promises/Async await" hreflang="x-default"><link rel="stylesheet" href="/anantblog/assets/css/styles.dd6252f0.css">
<link rel="preload" href="/anantblog/assets/js/runtime~main.424d7a41.js" as="script">
<link rel="preload" href="/anantblog/assets/js/main.6729f170.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><a class="navbar__brand" href="/anantblog/"><b class="navbar__title text--truncate">Blog</b></a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/anantblog/introduction">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/javascript">Javascript</a><button aria-label="Toggle the collapsible sidebar category &#x27;Javascript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/modules">Modules</a><button aria-label="Toggle the collapsible sidebar category &#x27;Modules&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/anantblog/category/promises">Promises</a><button aria-label="Toggle the collapsible sidebar category &#x27;Promises&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/anantblog/Promises/Async await">Async await</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Callbacks">Callbacks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Error Handling with Promises">Error Handling with Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Microtasks">Microtasks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise API">Promise API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promise Chaining">Promise Chaining</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises">Promises</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/anantblog/Promises/Promisifying">Promisifying</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/anantblog/category/code-snippets">Code Snippets</a><button aria-label="Toggle the collapsible sidebar category &#x27;Code Snippets&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/anantblog/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/anantblog/category/promises"><span itemprop="name">Promises</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Async await</span><meta itemprop="position" content="2"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>Async await</h1></header><p>There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use.</p><p>Async functions
Let’s start with the async keyword. It can be placed before a function, like this:</p><p>async function f() {
return 1;
}
The word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.</p><p>For instance, this function returns a resolved promise with the result of 1; let’s test it:</p><p>async function f() {
return 1;
}</p><p>f().then(alert); // 1
…We could explicitly return a promise, which would be the same:</p><p>async function f() {
return Promise.resolve(1);
}</p><p>f().then(alert); // 1
So, async ensures that the function returns a promise, and wraps non-promises in it. Simple enough, right? But not only that. There’s another keyword, await, that works only inside async functions, and it’s pretty cool.</p><p>Await
The syntax:</p><p>// works only inside async functions
let value = await promise;
The keyword await makes JavaScript wait until that promise settles and returns its result.</p><p>Here’s an example with a promise that resolves in 1 second:</p><p>async function f() {</p><p>  let promise = new Promise((resolve, reject) =&gt; {
setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000)
});</p><p>  let result = await promise; // wait until the promise resolves (*)</p><p>  alert(result); // &quot;done!&quot;
}</p><p>f();
The function execution “pauses” at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows “done!” in one second.</p><p>Let’s emphasize: await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.</p><p>It’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write.</p><p>Can’t use await in regular functions
If we try to use await in a non-async function, there would be a syntax error:</p><p>function f() {
let promise = Promise.resolve(1);
let result = await promise; // Syntax error
}
We may get this error if we forget to put async before a function. As stated earlier, await only works inside an async function.</p><p>Let’s take the showAvatar() example from the chapter Promises chaining and rewrite it using async/await:</p><p>We’ll need to replace .then calls with await.
Also we should make the function async for them to work.
async function showAvatar() {</p><p>  // read our JSON
let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
let user = await response.json();</p><p>  // read github user
let githubResponse = await fetch(<code>https://api.github.com/users/${user.name}</code>);
let githubUser = await githubResponse.json();</p><p>  // show the avatar
let img = document.createElement(&#x27;img&#x27;);
img.src = githubUser.avatar_url;
img.className = &quot;promise-avatar-example&quot;;
document.body.append(img);</p><p>  // wait 3 seconds
await new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));</p><p>  img.remove();</p><p>  return githubUser;
}</p><p>showAvatar();
Pretty clean and easy to read, right? Much better than before.</p><p>Modern browsers allow top-level await in modules
In modern browsers, await on top level works just fine, when we’re inside a module. We’ll cover modules in article Modules, introduction.</p><p>For instance:</p><p>// we assume this code runs at top level, inside a module
let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
let user = await response.json();</p><p>console.log(user);
If we’re not using modules, or older browsers must be supported, there’s a universal recipe: wrapping into an anonymous async function.</p><p>Like this:</p><p>(async () =&gt; {
let response = await fetch(&#x27;/article/promise-chaining/user.json&#x27;);
let user = await response.json();
...
})();
await accepts “thenables”
Like promise.then, await allows us to use thenable objects (those with a callable then method). The idea is that a third-party object may not be a promise, but promise-compatible: if it supports .then, that’s enough to use it with await.</p><p>Here’s a demo Thenable class; the await below accepts its instances:</p><p>class Thenable {
constructor(num) {
this.num = num;
}
then(resolve, reject) {
alert(resolve);
// resolve with this.num<em>2 after 1000ms
setTimeout(() =&gt; resolve(this.num </em> 2), 1000); // (*)
}
}</p><p>async function f() {
// waits for 1 second, then result becomes 2
let result = await new Thenable(1);
alert(result);
}</p><p>f();
If await gets a non-promise object with .then, it calls that method providing the built-in functions resolve and reject as arguments (just as it does for a regular Promise executor). Then await waits until one of them is called (in the example above it happens in the line (*)) and then proceeds with the result.</p><p>Async class methods
To declare an async class method, just prepend it with async:</p><p>class Waiter {
async wait() {
return await Promise.resolve(1);
}
}</p><p>new Waiter()
.wait()
.then(alert); // 1 (this is the same as (result =&gt; alert(result)))
The meaning is the same: it ensures that the returned value is a promise and enables await.</p><p>Error handling
If a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.</p><p>This code:</p><p>async function f() {
await Promise.reject(new Error(&quot;Whoops!&quot;));
}
…is the same as this:</p><p>async function f() {
throw new Error(&quot;Whoops!&quot;);
}
In real situations, the promise may take some time before it rejects. In that case there will be a delay before await throws an error.</p><p>We can catch that error using try..catch, the same way as a regular throw:</p><p>async function f() {</p><p>  try {
let response = await fetch(&#x27;http://no-such-url&#x27;);
} catch(err) {
alert(err); // TypeError: failed to fetch
}
}</p><p>f();
In the case of an error, the control jumps to the catch block. We can also wrap multiple lines:</p><p>async function f() {</p><p>  try {
let response = await fetch(&#x27;/no-user-here&#x27;);
let user = await response.json();
} catch(err) {
// catches errors both in fetch and response.json
alert(err);
}
}
f();
If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:</p><p>async function f() {
let response = await fetch(&#x27;http://no-such-url&#x27;);
}</p><p>// f() becomes a rejected promise
f().catch(alert); // TypeError: failed to fetch // (*)
If we forget to add .catch there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global unhandledrejection event handler as described in the chapter Error handling with promises.</p><p>async/await and promise.then/catch
When we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.</p><p>But at the top level of the code, when we’re outside any async function, we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error, like in the line (*) of the example above.</p><p>async/await works well with Promise.all
When we need to wait for multiple promises, we can wrap them in Promise.all and then await:</p><p>// wait for the array of results
let results = await Promise.all(<!-- -->[
fetch(url1),
fetch(url2),
...
]<!-- -->);
In the case of an error, it propagates as usual, from the failed promise to Promise.all, and then becomes an exception that we can catch using try..catch around the call.</p><p>Summary
The async keyword before a function has two effects:</p><p>Makes it always return a promise.
Allows await to be used in it.
The await keyword before a promise makes JavaScript wait until that promise settles, and then:</p><p>If it’s an error, an exception is generated — same as if throw error were called at that very place.
Otherwise, it returns the result.
Together they provide a great framework to write asynchronous code that is easy to both read and write.</p><p>With async/await we rarely need to write promise.then/catch, but we still shouldn’t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also Promise.all is nice when we are waiting for many tasks simultaneously.</p><p>Tasks
Rewrite using async/await
Rewrite this example code from the chapter Promises chaining using async/await instead of .then/catch:</p><p>function loadJson(url) {
return fetch(url)
.then(response =&gt; {
if (response.status == 200) {
return response.json();
} else {
throw new Error(response.status);
}
});
}</p><p>loadJson(&#x27;<a href="https://javascript.info/no-such-user.json&#x27;" target="_blank" rel="noopener noreferrer">https://javascript.info/no-such-user.json&#x27;</a>)
.catch(alert); // Error: 404
solution
The notes are below the code:</p><p>async function loadJson(url) { // (1)
let response = await fetch(url); // (2)</p><p>  if (response.status == 200) {
let json = await response.json(); // (3)
return json;
}</p><p>  throw new Error(response.status);
}</p><p>loadJson(&#x27;<a href="https://javascript.info/no-such-user.json&#x27;" target="_blank" rel="noopener noreferrer">https://javascript.info/no-such-user.json&#x27;</a>)
.catch(alert); // Error: 404 (4)</p><p>Rewrite &quot;rethrow&quot; with async/await
Below you can find the “rethrow” example. Rewrite it using async/await instead of .then/catch.</p><p>And get rid of the recursion in favour of a loop in demoGithubUser: with async/await that becomes easy to do.</p><p>class HttpError extends Error {
constructor(response) {
super(<code>${response.status} for ${response.url}</code>);
this.name = &#x27;HttpError&#x27;;
this.response = response;
}
}</p><p>function loadJson(url) {
return fetch(url)
.then(response =&gt; {
if (response.status == 200) {
return response.json();
} else {
throw new HttpError(response);
}
});
}</p><p>// Ask for a user name until github returns a valid user
function demoGithubUser() {
let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</p><p>  return loadJson(<code>https://api.github.com/users/${name}</code>)
.then(user =&gt; {
alert(<code>Full name: ${user.name}.</code>);
return user;
})
.catch(err =&gt; {
if (err instanceof HttpError &amp;&amp; err.response.status == 404) {
alert(&quot;No such user, please reenter.&quot;);
return demoGithubUser();
} else {
throw err;
}
});
}</p><p>demoGithubUser();
solution
There are no tricks here. Just replace .catch with try..catch inside demoGithubUser and add async/await where needed:</p><p>class HttpError extends Error {
constructor(response) {
super(<code>${response.status} for ${response.url}</code>);
this.name = &#x27;HttpError&#x27;;
this.response = response;
}
}</p><p>async function loadJson(url) {
let response = await fetch(url);
if (response.status == 200) {
return response.json();
} else {
throw new HttpError(response);
}
}</p><p>// Ask for a user name until github returns a valid user
async function demoGithubUser() {</p><p>  let user;
while(true) {
let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  user = await loadJson(`https://api.github.com/users/${name}`);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  break; // no error, exit loop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(err) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (err instanceof HttpError &amp;&amp; err.response.status == 404) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // loop continues after the alert</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alert(&quot;No such user, please reenter.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // unknown error, rethrow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  }</p><p>  alert(<code>Full name: ${user.name}.</code>);
return user;
}</p><p>demoGithubUser();</p><p>Call async from non-async
We have a “regular” function called f. How can you call the async function wait() and use its result inside of f?</p><p>async function wait() {
await new Promise(resolve =&gt; setTimeout(resolve, 1000));</p><p>  return 10;
}</p><p>function f() {
// ...what should you write here?
// we need to call async wait() and wait to get 10
// remember, we can&#x27;t use &quot;await&quot;
}
P.S. The task is technically very simple, but the question is quite common for developers new to async/await.</p><p>solution
That’s the case when knowing how it works inside is helpful.</p><p>Just treat async call as promise and attach .then to it:</p><p>async function wait() {
await new Promise(resolve =&gt; setTimeout(resolve, 1000));</p><p>  return 10;
}</p><p>function f() {
// shows 10 after 1 second
wait().then(result =&gt; alert(result));
}
f();</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/anantblog/category/promises"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Promises</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/anantblog/Promises/Callbacks"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Callbacks</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022</div></div></div></footer></div>
<script src="/anantblog/assets/js/runtime~main.424d7a41.js"></script>
<script src="/anantblog/assets/js/main.6729f170.js"></script>
</body>
</html>