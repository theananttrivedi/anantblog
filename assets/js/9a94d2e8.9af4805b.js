"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[289],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),c=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},h=function(e){var t=c(e.components);return r.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,i=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=o,m=p["".concat(i,".").concat(d)]||p[d]||u[d]||s;return n?r.createElement(m,a(a({ref:t},h),{},{components:n})):r.createElement(m,a({ref:t},h))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=p;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var c=2;c<s;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const s={},a=void 0,l={unversionedId:"Promises/Promises",id:"Promises/Promises",title:"Promises",description:"Imagine that you\u2019re a top singer, and fans ask day and night for your upcoming song.",source:"@site/docs/Promises/Promises.md",sourceDirName:"Promises",slug:"/Promises/",permalink:"/anantblog/Promises/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Promise Chaining",permalink:"/anantblog/Promises/Promise Chaining"},next:{title:"Promisifying",permalink:"/anantblog/Promises/Promisifying"}},i={},c=[],h={toc:c};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Imagine that you\u2019re a top singer, and fans ask day and night for your upcoming song."),(0,o.kt)("p",null,"To get some relief, you promise to send it to them when it\u2019s published. You give your fans a list. They can fill in their email addresses, so that when the song becomes available, all subscribed parties instantly receive it. And even if something goes very wrong, say, a fire in the studio, so that you can\u2019t publish the song, they will still be notified."),(0,o.kt)("p",null,"Everyone is happy: you, because the people don\u2019t crowd you anymore, and fans, because they won\u2019t miss the song."),(0,o.kt)("p",null,"This is a real-life analogy for things we often have in programming:"),(0,o.kt)("p",null,"A \u201cproducing code\u201d that does something and takes time. For instance, some code that loads the data over a network. That\u2019s a \u201csinger\u201d.\nA \u201cconsuming code\u201d that wants the result of the \u201cproducing code\u201d once it\u2019s ready. Many functions may need that result. These are the \u201cfans\u201d.\nA promise is a special JavaScript object that links the \u201cproducing code\u201d and the \u201cconsuming code\u201d together. In terms of our analogy: this is the \u201csubscription list\u201d. The \u201cproducing code\u201d takes whatever time it needs to produce the promised result, and the \u201cpromise\u201d makes that result available to all of the subscribed code when it\u2019s ready.\nThe analogy isn\u2019t terribly accurate, because JavaScript promises are more complex than a simple subscription list: they have additional features and limitations. But it\u2019s fine to begin with."),(0,o.kt)("p",null,"The constructor syntax for a promise object is:"),(0,o.kt)("p",null,'let promise = new Promise(function(resolve, reject) {\n// executor (the producing code, "singer")\n});\nThe function passed to new Promise is called the executor. When new Promise is created, the executor runs automatically. It contains the producing code which should eventually produce the result. In terms of the analogy above: the executor is the \u201csinger\u201d.'),(0,o.kt)("p",null,"Its arguments resolve and reject are callbacks provided by JavaScript itself. Our code is only inside the executor."),(0,o.kt)("p",null,"When the executor obtains the result, be it soon or late, doesn\u2019t matter, it should call one of these callbacks:"),(0,o.kt)("p",null,"resolve(value) \u2014 if the job is finished successfully, with result value.\nreject(error) \u2014 if an error has occurred, error is the error object.\nSo to summarize: the executor runs automatically and attempts to perform a job. When it is finished with the attempt, it calls resolve if it was successful or reject if there was an error."),(0,o.kt)("p",null,"The promise object returned by the new Promise constructor has these internal properties:"),(0,o.kt)("p",null,'state \u2014 initially "pending", then changes to either "fulfilled" when resolve is called or "rejected" when reject is called.\nresult \u2014 initially undefined, then changes to value when resolve(value) is called or error when reject(error) is called.\nSo the executor eventually moves promise to one of these states:'),(0,o.kt)("p",null,"Later we\u2019ll see how \u201cfans\u201d can subscribe to these changes."),(0,o.kt)("p",null,"Here\u2019s an example of a promise constructor and a simple executor function with \u201cproducing code\u201d that takes time (via setTimeout):"),(0,o.kt)("p",null,"let promise = new Promise(function(resolve, reject) {\n// the function is executed automatically when the promise is constructed"),(0,o.kt)("p",null,'  // after 1 second signal that the job is done with the result "done"\nsetTimeout(() => resolve("done"), 1000);\n});\nWe can see two things by running the code above:'),(0,o.kt)("p",null,"The executor is called automatically and immediately (by new Promise)."),(0,o.kt)("p",null,"The executor receives two arguments: resolve and reject. These functions are pre-defined by the JavaScript engine, so we don\u2019t need to create them. We should only call one of them when ready."),(0,o.kt)("p",null,'After one second of \u201cprocessing\u201d, the executor calls resolve("done") to produce the result. This changes the state of the promise object:'),(0,o.kt)("p",null,"That was an example of a successful job completion, a \u201cfulfilled promise\u201d."),(0,o.kt)("p",null,"And now an example of the executor rejecting the promise with an error:"),(0,o.kt)("p",null,'let promise = new Promise(function(resolve, reject) {\n// after 1 second signal that the job is finished with an error\nsetTimeout(() => reject(new Error("Whoops!")), 1000);\n});\nThe call to reject(...) moves the promise object to "rejected" state:'),(0,o.kt)("p",null,"To summarize, the executor should perform a job (usually something that takes time) and then call resolve or reject to change the state of the corresponding promise object."),(0,o.kt)("p",null,"A promise that is either resolved or rejected is called \u201csettled\u201d, as opposed to an initially \u201cpending\u201d promise."),(0,o.kt)("p",null,"There can be only a single result or an error\nThe executor should call only one resolve or one reject. Any state change is final."),(0,o.kt)("p",null,"All further calls of resolve and reject are ignored:"),(0,o.kt)("p",null,'let promise = new Promise(function(resolve, reject) {\nresolve("done");'),(0,o.kt)("p",null,'  reject(new Error("\u2026")); // ignored\nsetTimeout(() => resolve("\u2026")); // ignored\n});\nThe idea is that a job done by the executor may have only one result or an error.'),(0,o.kt)("p",null,"Also, resolve/reject expect only one argument (or none) and will ignore additional arguments."),(0,o.kt)("p",null,"Reject with Error objects\nIn case something goes wrong, the executor should call reject. That can be done with any type of argument (just like resolve). But it is recommended to use Error objects (or objects that inherit from Error). The reasoning for that will soon become apparent."),(0,o.kt)("p",null,"Immediately calling resolve/reject\nIn practice, an executor usually does something asynchronously and calls resolve/reject after some time, but it doesn\u2019t have to. We also can call resolve or reject immediately, like this:"),(0,o.kt)("p",null,"let promise = new Promise(function(resolve, reject) {\n// not taking our time to do the job\nresolve(123); // immediately give the result: 123\n});\nFor instance, this might happen when we start to do a job but then see that everything has already been completed and cached."),(0,o.kt)("p",null,"That\u2019s fine. We immediately have a resolved promise."),(0,o.kt)("p",null,"The state and result are internal\nThe properties state and result of the Promise object are internal. We can\u2019t directly access them. We can use the methods .then/.catch/.finally for that. They are described below."),(0,o.kt)("p",null,"Consumers: then, catch\nA Promise object serves as a link between the executor (the \u201cproducing code\u201d or \u201csinger\u201d) and the consuming functions (the \u201cfans\u201d), which will receive the result or error. Consuming functions can be registered (subscribed) using the methods .then and .catch."),(0,o.kt)("p",null,"then\nThe most important, fundamental one is .then."),(0,o.kt)("p",null,"The syntax is:"),(0,o.kt)("p",null,"promise.then(\nfunction(result) { /",(0,o.kt)("em",{parentName:"p"}," handle a successful result "),"/ },\nfunction(error) { /",(0,o.kt)("em",{parentName:"p"}," handle an error "),"/ }\n);\nThe first argument of .then is a function that runs when the promise is resolved and receives the result."),(0,o.kt)("p",null,"The second argument of .then is a function that runs when the promise is rejected and receives the error."),(0,o.kt)("p",null,"For instance, here\u2019s a reaction to a successfully resolved promise:"),(0,o.kt)("p",null,'let promise = new Promise(function(resolve, reject) {\nsetTimeout(() => resolve("done!"), 1000);\n});'),(0,o.kt)("p",null,'// resolve runs the first function in .then\npromise.then(\nresult => alert(result), // shows "done!" after 1 second\nerror => alert(error) // doesn\'t run\n);\nThe first function was executed.'),(0,o.kt)("p",null,"And in the case of a rejection, the second one:"),(0,o.kt)("p",null,'let promise = new Promise(function(resolve, reject) {\nsetTimeout(() => reject(new Error("Whoops!")), 1000);\n});'),(0,o.kt)("p",null,'// reject runs the second function in .then\npromise.then(\nresult => alert(result), // doesn\'t run\nerror => alert(error) // shows "Error: Whoops!" after 1 second\n);\nIf we\u2019re interested only in successful completions, then we can provide only one function argument to .then:'),(0,o.kt)("p",null,'let promise = new Promise(resolve => {\nsetTimeout(() => resolve("done!"), 1000);\n});'),(0,o.kt)("p",null,'promise.then(alert); // shows "done!" after 1 second\ncatch\nIf we\u2019re interested only in errors, then we can use null as the first argument: .then(null, errorHandlingFunction). Or we can use .catch(errorHandlingFunction), which is exactly the same:'),(0,o.kt)("p",null,'let promise = new Promise((resolve, reject) => {\nsetTimeout(() => reject(new Error("Whoops!")), 1000);\n});'),(0,o.kt)("p",null,'// .catch(f) is the same as promise.then(null, f)\npromise.catch(alert); // shows "Error: Whoops!" after 1 second\nThe call .catch(f) is a complete analog of .then(null, f), it\u2019s just a shorthand.'),(0,o.kt)("p",null,"Cleanup: finally\nJust like there\u2019s a finally clause in a regular try {...} catch {...}, there\u2019s finally in promises."),(0,o.kt)("p",null,"The call .finally(f) is similar to .then(f, f) in the sense that f runs always, when the promise is settled: be it resolve or reject."),(0,o.kt)("p",null,"The idea of finally is to set up a handler for performing cleanup/finalizing after the previous operations are complete."),(0,o.kt)("p",null,"E.g. stopping loading indicators, closing no longer needed connections, etc."),(0,o.kt)("p",null,"Think of it as a party finisher. No matter was a party good or bad, how many friends were in it, we still need (or at least should) do a cleanup after it."),(0,o.kt)("p",null,"The code may look like this:"),(0,o.kt)("p",null,"new Promise((resolve, reject) => {\n/",(0,o.kt)("em",{parentName:"p"}," do something that takes time, and then call resolve or maybe reject "),"/\n})\n// runs when the promise is settled, doesn't matter successfully or not\n.finally(() => stop loading indicator)\n// so the loading indicator is always stopped before we go on\n.then(result => show result, err => show error)\nPlease note that finally(f) isn\u2019t exactly an alias of then(f,f) though."),(0,o.kt)("p",null,"There are important differences:"),(0,o.kt)("p",null,"A finally handler has no arguments. In finally we don\u2019t know whether the promise is successful or not. That\u2019s all right, as our task is usually to perform \u201cgeneral\u201d finalizing procedures."),(0,o.kt)("p",null,"Please take a look at the example above: as you can see, the finally handler has no arguments, and the promise outcome is handled by the next handler."),(0,o.kt)("p",null,"A finally handler \u201cpasses through\u201d the result or error to the next suitable handler."),(0,o.kt)("p",null,"For instance, here the result is passed through finally to then:"),(0,o.kt)("p",null,'new Promise((resolve, reject) => {\nsetTimeout(() => resolve("value"), 2000);\n})\n.finally(() => alert("Promise ready")) // triggers first\n.then(result => alert(result)); // <-- .then shows "value"\nAs you can see, the value returned by the first promise is passed through finally to the next then.'),(0,o.kt)("p",null,"That\u2019s very convenient, because finally is not meant to process a promise result. As said, it\u2019s a place to do generic cleanup, no matter what the outcome was."),(0,o.kt)("p",null,"And here\u2019s an example of an error, for us to see how it\u2019s passed through finally to catch:"),(0,o.kt)("p",null,'new Promise((resolve, reject) => {\nthrow new Error("error");\n})\n.finally(() => alert("Promise ready")) // triggers first\n.catch(err => alert(err));  // <-- .catch shows the error\nA finally handler also shouldn\u2019t return anything. If it does, the returned value is silently ignored.'),(0,o.kt)("p",null,"The only exception to this rule is when a finally handler throws an error. Then this error goes to the next handler, instead of any previous outcome."),(0,o.kt)("p",null,"To summarize:"),(0,o.kt)("p",null,"A finally handler doesn\u2019t get the outcome of the previous handler (it has no arguments). This outcome is passed through instead, to the next suitable handler.\nIf a finally handler returns something, it\u2019s ignored.\nWhen finally throws an error, then the execution goes to the nearest error handler."),(0,o.kt)("p",null,"To summarize:"),(0,o.kt)("p",null,"A finally handler doesn\u2019t get the outcome of the previous handler (it has no arguments). This outcome is passed through instead, to the next suitable handler.\nIf a finally handler returns something, it\u2019s ignored.\nWhen finally throws an error, then the execution goes to the nearest error handler.\nThese features are helpful and make things work just the right way if we use finally how it\u2019s supposed to be used: for generic cleanup procedures."),(0,o.kt)("p",null,"We can attach handlers to settled promises\nIf a promise is pending, .then/catch/finally handlers wait for its outcome."),(0,o.kt)("p",null,"Sometimes, it might be that a promise is already settled when we add a handler to it."),(0,o.kt)("p",null,"In such case, these handlers just run immediately:"),(0,o.kt)("p",null,'// the promise becomes resolved immediately upon creation\nlet promise = new Promise(resolve => resolve("done!"));'),(0,o.kt)("p",null,"promise.then(alert); // done! (shows up right now)\nNote that this makes promises more powerful than the real life \u201csubscription list\u201d scenario. If the singer has already released their song and then a person signs up on the subscription list, they probably won\u2019t receive that song. Subscriptions in real life must be done prior to the event."),(0,o.kt)("p",null,"Promises are more flexible. We can add handlers any time: if the result is already there, they just execute."),(0,o.kt)("p",null,"Example: loadScript\nNext, let\u2019s see more practical examples of how promises can help us write asynchronous code."),(0,o.kt)("p",null,"We\u2019ve got the loadScript function for loading a script from the previous chapter."),(0,o.kt)("p",null,"Here\u2019s the callback-based variant, just to remind us of it:"),(0,o.kt)("p",null,"function loadScript(src, callback) {\nlet script = document.createElement('script');\nscript.src = src;"),(0,o.kt)("p",null,"  script.onload = () => callback(null, script);\nscript.onerror = () => callback(new Error(",(0,o.kt)("inlineCode",{parentName:"p"},"Script load error for ${src}"),"));"),(0,o.kt)("p",null,"  document.head.append(script);\n}\nLet\u2019s rewrite it using Promises."),(0,o.kt)("p",null,"The new function loadScript will not require a callback. Instead, it will create and return a Promise object that resolves when the loading is complete. The outer code can add handlers (subscribing functions) to it using .then:"),(0,o.kt)("p",null,"function loadScript(src) {\nreturn new Promise(function(resolve, reject) {\nlet script = document.createElement('script');\nscript.src = src;"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"script.onload = () => resolve(script);\nscript.onerror = () => reject(new Error(`Script load error for ${src}`));\n\ndocument.head.append(script);\n")),(0,o.kt)("p",null,"  });\n}\nUsage:"),(0,o.kt)("p",null,'let promise = loadScript("',(0,o.kt)("a",{parentName:"p",href:"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js%22)"},'https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js")'),";"),(0,o.kt)("p",null,"promise.then(\nscript => alert(",(0,o.kt)("inlineCode",{parentName:"p"},"${script.src} is loaded!"),"),\nerror => alert(",(0,o.kt)("inlineCode",{parentName:"p"},"Error: ${error.message}"),")\n);"),(0,o.kt)("p",null,"promise.then(script => alert('Another handler...'));\nWe can immediately see a few benefits over the callback-based pattern:"),(0,o.kt)("p",null,"Promises\tCallbacks\nPromises allow us to do things in the natural order. First, we run loadScript(script), and .then we write what to do with the result.\tWe must have a callback function at our disposal when calling loadScript(script, callback). In other words, we must know what to do with the result before loadScript is called.\nWe can call .then on a Promise as many times as we want. Each time, we\u2019re adding a new \u201cfan\u201d, a new subscribing function, to the \u201csubscription list\u201d. More about this in the next chapter: Promises chaining.\tThere can be only one callback.\nSo promises give us better code flow and flexibility. But there\u2019s more. We\u2019ll see that in the next chapters."),(0,o.kt)("p",null,"Tasks\nRe-resolve a promise?\nWhat\u2019s the output of the code below?"),(0,o.kt)("p",null,"let promise = new Promise(function(resolve, reject) {\nresolve(1);"),(0,o.kt)("p",null,"  setTimeout(() => resolve(2), 1000);\n});"),(0,o.kt)("p",null,"promise.then(alert);"))}u.isMDXComponent=!0}}]);