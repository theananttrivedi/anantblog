"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[199],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),p=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(i.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=o,f=d["".concat(i,".").concat(c)]||d[c]||m[c]||a;return n?r.createElement(f,s(s({ref:t},u),{},{components:n})):r.createElement(f,s({ref:t},u))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var p=2;p<a;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var r=n(7462),o=(n(7294),n(3905));const a={},s=void 0,l={unversionedId:"Modules/export-and-import",id:"Modules/export-and-import",title:"export-and-import",description:"Export and import directives have several syntax variants.",source:"@site/docs/Modules/export-and-import.md",sourceDirName:"Modules",slug:"/Modules/export-and-import",permalink:"/anantblog/Modules/export-and-import",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Dynamic Imports",permalink:"/anantblog/Modules/dynamic-imports"},next:{title:"modules-introduction",permalink:"/anantblog/Modules/modules-introduction"}},i={},p=[{value:"Export default",id:"export-default",level:2}],u={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Export and import directives have several syntax variants."),(0,o.kt)("p",null,"In the previous article we saw a simple use, now let\u2019s explore more examples."),(0,o.kt)("p",null,"Export before declarations\nWe can label any declaration as exported by placing export before it, be it a variable, function or a class."),(0,o.kt)("p",null,"For instance, here all exports are valid:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// export an array\nexport let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n// export a constant\nexport const MODULES_BECAME_STANDARD_YEAR = 2015;\n\n// export a class\nexport class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n")),(0,o.kt)("p",null,"No semicolons after export class/function\nPlease note that export before a class or a function does not make it a function expression. It\u2019s still a function declaration, albeit exported."),(0,o.kt)("p",null,"Most JavaScript style guides don\u2019t recommend semicolons after function and class declarations."),(0,o.kt)("p",null,"That\u2019s why there\u2019s no need for a semicolon at the end of export class and export function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}  // no ; at the end\n\n")),(0,o.kt)("p",null,"Export apart from declarations\nAlso, we can put export separately."),(0,o.kt)("p",null,"Here we first declare, and then export:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 say.js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\nexport {sayHi, sayBye}; // a list of exported variables\n")),(0,o.kt)("p",null,"\u2026Or, technically we could put export above functions as well."),(0,o.kt)("p",null,"Import *\nUsually, we put a list of what to import in curly braces import {...}, like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 main.js\nimport {sayHi, sayBye} from './say.js';\n\nsayHi('John'); // Hello, John!\nsayBye('John'); // Bye, John!\nBut if there\u2019s a lot to import, we can import everything as an object using import * as <obj>, for instance:\n\n// \ud83d\udcc1 main.js\nimport * as say from './say.js';\n\nsay.sayHi('John');\nsay.sayBye('John');\n\n")),(0,o.kt)("p",null,"At first sight, \u201cimport everything\u201d seems such a cool thing, short to write, why should we ever explicitly list what we need to import?"),(0,o.kt)("p",null,"Well, there are few reasons."),(0,o.kt)("p",null,"Explicitly listing what to import gives shorter names: sayHi() instead of say.sayHi().\nExplicit list of imports gives better overview of the code structure: what is used and where. It makes code support and refactoring easier.\nDon\u2019t be afraid to import too much\nModern build tools, such as webpack and others, bundle modules together and optimize them to speedup loading. They also removed unused imports."),(0,o.kt)("p",null,"For instance, if you import * as library from a huge code library, and then use only few methods, then unused ones will not be included into the optimzed bundle."),(0,o.kt)("p",null,"Import \u201cas\u201d\nWe can also use as to import under different names."),(0,o.kt)("p",null,"For instance, let\u2019s import sayHi into the local variable hi for brevity, and import sayBye as bye:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 main.js\nimport {sayHi as hi, sayBye as bye} from './say.js';\n\nhi('John'); // Hello, John!\nbye('John'); // Bye, John!\n")),(0,o.kt)("p",null,"Export \u201cas\u201d\nThe similar syntax exists for export."),(0,o.kt)("p",null,"Let\u2019s export functions as hi and bye:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 say.js\nexport {sayHi as hi, sayBye as bye};\nNow hi and bye are official names for outsiders, to be used in imports:\n\n// \ud83d\udcc1 main.js\nimport * as say from './say.js';\n\nsay.hi('John'); // Hello, John!\nsay.bye('John'); // Bye, John!\n")),(0,o.kt)("h2",{id:"export-default"},"Export default"),(0,o.kt)("p",null,"In practice, there are mainly two kinds of modules."),(0,o.kt)("p",null,"Modules that contain a library, pack of functions, like say.js above.\nModules that declare a single entity, e.g. a module user.js exports only class User.\nMostly, the second approach is preferred, so that every \u201cthing\u201d resides in its own module."),(0,o.kt)("p",null,"Naturally, that requires a lot of files, as everything wants its own module, but that\u2019s not a problem at all. Actually, code navigation becomes easier if files are well-named and structured into folders."),(0,o.kt)("p",null,"Modules provide a special export default (\u201cthe default export\u201d) syntax to make the \u201cone thing per module\u201d way look better."),(0,o.kt)("p",null,"Put export default before the entity to export:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'// \ud83d\udcc1 user.js\nexport default class User { // just add "default"\n  constructor(name) {\n    this.name = name;\n  }\n}\n')),(0,o.kt)("p",null,"There may be only one export default per file."),(0,o.kt)("p",null,"\u2026And then import it without curly braces:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 main.js\nimport User from './user.js'; // not {User}, just User\n\nnew User('John');\n")),(0,o.kt)("p",null,"Imports without curly braces look nicer. A common mistake when starting to use modules is to forget curly braces at all. So, remember, import needs curly braces for named exports and doesn\u2019t need them for the default one."),(0,o.kt)("p",null,"Named export\tDefault export"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export class User {...} export default class User {...}\nimport {User} from ...  import User from ...\n")),(0,o.kt)("p",null,"Technically, we may have both default and named exports in a single module, but in practice people usually don\u2019t mix them. A module has either named exports or the default one."),(0,o.kt)("p",null,"As there may be at most one default export per file, the exported entity may have no name."),(0,o.kt)("p",null,"For instance, these are all perfectly valid default exports:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export default class { // no class name\n  constructor() { ... }\n}\nexport default function(user) { // no function name\n  alert(`Hello, ${user}!`);\n}\n// export a single value, without making a variable\nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n")),(0,o.kt)("p",null,"Not giving a name is fine, because there is only one export default per file, so import without curly braces knows what to import."),(0,o.kt)("p",null,"Without default, such an export would give an error:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export class { // Error! (non-default export needs a name)\n  constructor() {}\n}\n")),(0,o.kt)("p",null,"The \u201cdefault\u201d name\nIn some situations the default keyword is used to reference the default export."),(0,o.kt)("p",null,"For example, to export a function separately from its definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// same as if we added "export default" before the function\nexport {sayHi as default};\n\n')),(0,o.kt)("p",null,"Or, another situation, let\u2019s say a module user.js exports one main \u201cdefault\u201d thing, and a few named ones (rarely the case, but it happens):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n")),(0,o.kt)("p",null,"Here\u2019s how to import the default export along with a named one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 main.js\nimport {default as User, sayHi} from './user.js';\n\nnew User('John');\n")),(0,o.kt)("p",null,"And, finally, if importing everything * as an object, then the default property is exactly the default export:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 main.js\nimport * as user from './user.js';\n\nlet User = user.default; // the default export\nnew User('John');\n\n")),(0,o.kt)("p",null,"A word against default exports\nNamed exports are explicit. They exactly name what they import, so we have that information from them; that\u2019s a good thing."),(0,o.kt)("p",null,"Named exports force us to use exactly the right name to import:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {User} from './user.js';\n")),(0,o.kt)("p",null,"// import {MyUser} won't work, the name must be {User}\n\u2026While for a default export, we always choose the name when importing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import User from './user.js'; // works\nimport MyUser from './user.js'; // works too\n// could be import Anything... and it'll still work\n")),(0,o.kt)("p",null,"So team members may use different names to import the same thing, and that\u2019s not good."),(0,o.kt)("p",null,"Usually, to avoid that and keep the code consistent, there\u2019s a rule that imported variables should correspond to file names, e.g:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import User from './user.js';\nimport LoginForm from './loginForm.js';\nimport func from '/path/to/func.js';\n...\n")),(0,o.kt)("p",null,"Still, some teams consider it a serious drawback of default exports. So they prefer to always use named exports. Even if only a single thing is exported, it\u2019s still exported under a name, without default."),(0,o.kt)("p",null,"That also makes re-export (see below) a little bit easier."),(0,o.kt)("p",null,"Re-export\n\u201cRe-export\u201d syntax export ... from ... allows to import things and immediately export them (possibly under another name), like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export {sayHi} from './say.js'; // re-export sayHi\n\nexport {default as User} from './user.js'; // re-export default\n")),(0,o.kt)("p",null,"Why would that be needed? Let\u2019s see a practical use case."),(0,o.kt)("p",null,"Imagine, we\u2019re writing a \u201cpackage\u201d: a folder with a lot of modules, with some of the functionality exported outside (tools like NPM allow us to publish and distribute such packages, but we don\u2019t have to use them), and many modules are just \u201chelpers\u201d, for internal use in other package modules."),(0,o.kt)("p",null,"The file structure could be like this:"),(0,o.kt)("p",null,"auth/\nindex.js\nuser.js\nhelpers.js\ntests/\nlogin.js\nproviders/\ngithub.js\nfacebook.js\n...\nWe\u2019d like to expose the package functionality via a single entry point."),(0,o.kt)("p",null,"In other words, a person who would like to use our package, should import only from the \u201cmain file\u201d auth/index.js."),(0,o.kt)("p",null,"Like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {login, logout} from 'auth/index.js'\n")),(0,o.kt)("p",null,"The \u201cmain file\u201d, auth/index.js exports all the functionality that we\u2019d like to provide in our package."),(0,o.kt)("p",null,"The idea is that outsiders, other programmers who use our package, should not meddle with its internal structure, search for files inside our package folder. We export only what\u2019s necessary in auth/index.js and keep the rest hidden from prying eyes."),(0,o.kt)("p",null,"As the actual exported functionality is scattered among the package, we can import it into auth/index.js and export from it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 auth/index.js\n\n// import login/logout and immediately export them\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\n// import default as User and export it\nimport User from './user.js';\nexport {User};\n")),(0,o.kt)("p",null,'...\nNow users of our package can import {login} from "auth/index.js".'),(0,o.kt)("p",null,"The syntax export ... from ... is just a shorter notation for such import-export:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 auth/index.js\n// re-export login/logout\nexport {login, logout} from './helpers.js';\n\n// re-export the default export as User\nexport {default as User} from './user.js';\n...\n")),(0,o.kt)("p",null,"The notable difference of export ... from compared to import/export is that re-exported modules aren\u2019t available in the current file. So inside the above example of auth/index.js we can\u2019t use re-exported login/logout functions."),(0,o.kt)("p",null,"Re-exporting the default export\nThe default export needs separate handling when re-exporting."),(0,o.kt)("p",null,"Let\u2019s say we have user.js with the export default class User and would like to re-export it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// \ud83d\udcc1 user.js\nexport default class User {\n  // ...\n}\n")),(0,o.kt)("p",null,"We can come across two problems with it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export User from './user.js'\n")),(0,o.kt)("p",null,"won\u2019t work. That would lead to a syntax error."),(0,o.kt)("p",null,"To re-export the default export, we have to write "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export {default as User}\n")),(0,o.kt)("p",null,", as in the example above."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export * from './user.js'\n")),(0,o.kt)("p",null," re-exports only named exports, but ignores the default one."),(0,o.kt)("p",null,"If we\u2019d like to re-export both named and default exports, then two statements are needed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"export * from './user.js'; // to re-export named exports\nexport {default} from './user.js'; // to re-export the default export\n")),(0,o.kt)("p",null,"Such oddities of re-exporting a default export are one of the reasons why some developers don\u2019t like default exports and prefer named ones."),(0,o.kt)("p",null,"Summary\nHere are all types of export that we covered in this and previous articles."),(0,o.kt)("p",null,"You can check yourself by reading them and recalling what they mean:"),(0,o.kt)("p",null,"Before declaration of a class/function/\u2026:\nexport ","[default]"," class/function/variable ...\nStandalone export:\nexport {x ","[as y]",", ...}.\nRe-export:\nexport {x ","[as y]",', ...} from "module"\nexport * from "module" (doesn\u2019t re-export default).\nexport {default ',"[as y]",'} from "module" (re-export default).\nImport:'),(0,o.kt)("p",null,"Importing named exports:\nimport {x ","[as y]",', ...} from "module"\nImporting the default export:\nimport x from "module"\nimport {default as x} from "module"\nImport all:\nimport * as obj from "module"\nImport the module (its code runs), but do not assign any of its exports to variables:\nimport "module"\nWe can put import/export statements at the top or at the bottom of a script, that doesn\u2019t matter.'),(0,o.kt)("p",null,"So, technically this code is fine:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"sayHi();\n\n// ...\n\nimport {sayHi} from './say.js'; // import at the end of the file\n")),(0,o.kt)("p",null,"In practice imports are usually at the start of the file, but that\u2019s only for more convenience."),(0,o.kt)("p",null,"Please note that import/export statements don\u2019t work if inside {...}."),(0,o.kt)("p",null,"A conditional import, like this, won\u2019t work:"),(0,o.kt)("p",null,'if (something) {\nimport {sayHi} from "./say.js"; // Error: import must be at top level\n}\n\u2026But what if we really need to import something conditionally? Or at the right time? Like, load a module upon request, when it\u2019s really needed?'))}m.isMDXComponent=!0}}]);