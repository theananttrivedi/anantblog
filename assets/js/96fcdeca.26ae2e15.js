"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[498],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(n),p=a,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3877:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={},i=void 0,s={unversionedId:"Promises/Microtasks",id:"Promises/Microtasks",title:"Microtasks",description:"Promise handlers .then/.catch/.finally are always asynchronous.",source:"@site/docs/Promises/Microtasks.md",sourceDirName:"Promises",slug:"/Promises/Microtasks",permalink:"/anantblog/Promises/Microtasks",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Error Handling with Promises",permalink:"/anantblog/Promises/Error Handling with Promises"},next:{title:"Promise API",permalink:"/anantblog/Promises/Promise API"}},l={},c=[],u={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Promise handlers .then/.catch/.finally are always asynchronous."),(0,a.kt)("p",null,"Even when a Promise is immediately resolved, the code on the lines below .then/.catch/.finally will still execute before these handlers."),(0,a.kt)("p",null,"Here\u2019s a demo:"),(0,a.kt)("p",null,"let promise = Promise.resolve();"),(0,a.kt)("p",null,'promise.then(() => alert("promise done!"));'),(0,a.kt)("p",null,'alert("code finished"); // this alert shows first\nIf you run it, you see code finished first, and then promise done!.'),(0,a.kt)("p",null,"That\u2019s strange, because the promise is definitely done from the beginning."),(0,a.kt)("p",null,"Why did the .then trigger afterwards? What\u2019s going on?"),(0,a.kt)("p",null,"Microtasks queue\nAsynchronous tasks need proper management. For that, the ECMA standard specifies an internal queue PromiseJobs, more often referred to as the \u201cmicrotask queue\u201d (V8 term)."),(0,a.kt)("p",null,"As stated in the specification:"),(0,a.kt)("p",null,"The queue is first-in-first-out: tasks enqueued first are run first.\nExecution of a task is initiated only when nothing else is running.\nOr, to put it more simply, when a promise is ready, its .then/catch/finally handlers are put into the queue; they are not executed yet. When the JavaScript engine becomes free from the current code, it takes a task from the queue and executes it."),(0,a.kt)("p",null,"That\u2019s why \u201ccode finished\u201d in the example above shows first."),(0,a.kt)("p",null,"Promise handlers always go through this internal queue."),(0,a.kt)("p",null,"If there\u2019s a chain with multiple .then/catch/finally, then every one of them is executed asynchronously. That is, it first gets queued, then executed when the current code is complete and previously queued handlers are finished."),(0,a.kt)("p",null,"What if the order matters for us? How can we make code finished appear after promise done?"),(0,a.kt)("p",null,"Easy, just put it into the queue with .then:"),(0,a.kt)("p",null,'Promise.resolve()\n.then(() => alert("promise done!"))\n.then(() => alert("code finished"));\nNow the order is as intended.'),(0,a.kt)("p",null,"Unhandled rejection\nRemember the unhandledrejection event from the article Error handling with promises?"),(0,a.kt)("p",null,"Now we can see exactly how JavaScript finds out that there was an unhandled rejection."),(0,a.kt)("p",null,"An \u201cunhandled rejection\u201d occurs when a promise error is not handled at the end of the microtask queue."),(0,a.kt)("p",null,"Normally, if we expect an error, we add .catch to the promise chain to handle it:"),(0,a.kt)("p",null,"let promise = Promise.reject(new Error(\"Promise Failed!\"));\npromise.catch(err => alert('caught'));"),(0,a.kt)("p",null,"// doesn't run: error handled\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\nBut if we forget to add .catch, then, after the microtask queue is empty, the engine triggers the event:"),(0,a.kt)("p",null,'let promise = Promise.reject(new Error("Promise Failed!"));'),(0,a.kt)("p",null,"// Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\nWhat if we handle the error later? Like this:"),(0,a.kt)("p",null,"let promise = Promise.reject(new Error(\"Promise Failed!\"));\nsetTimeout(() => promise.catch(err => alert('caught')), 1000);"),(0,a.kt)("p",null,"// Error: Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\nNow, if we run it, we\u2019ll see Promise Failed! first and then caught."),(0,a.kt)("p",null,"If we didn\u2019t know about the microtasks queue, we could wonder: \u201cWhy did unhandledrejection handler run? We did catch and handle the error!\u201d"),(0,a.kt)("p",null,"But now we understand that unhandledrejection is generated when the microtask queue is complete: the engine examines promises and, if any of them is in the \u201crejected\u201d state, then the event triggers."),(0,a.kt)("p",null,"In the example above, .catch added by setTimeout also triggers. But it does so later, after unhandledrejection has already occurred, so it doesn\u2019t change anything."),(0,a.kt)("p",null,"Summary\nPromise handling is always asynchronous, as all promise actions pass through the internal \u201cpromise jobs\u201d queue, also called \u201cmicrotask queue\u201d (V8 term)."),(0,a.kt)("p",null,"So .then/catch/finally handlers are always called after the current code is finished."),(0,a.kt)("p",null,"If we need to guarantee that a piece of code is executed after .then/catch/finally, we can add it into a chained .then call."),(0,a.kt)("p",null,"In most Javascript engines, including browsers and Node.js, the concept of microtasks is closely tied with the \u201cevent loop\u201d and \u201cmacrotasks\u201d."))}d.isMDXComponent=!0}}]);