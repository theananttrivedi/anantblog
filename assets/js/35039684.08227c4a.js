"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[424],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),f=c(r),m=a,h=f["".concat(s,".").concat(m)]||f[m]||p[m]||o;return r?n.createElement(h,i(i({ref:t},u),{},{components:r})):n.createElement(h,i({ref:t},u))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},3814:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const o={},i=void 0,l={unversionedId:"Promises/Promisifying",id:"Promises/Promisifying",title:"Promisifying",description:"\u201cPromisification\u201d is a long word for a simple transformation. It\u2019s the conversion of a function that accepts a callback into a function that returns a promise.",source:"@site/docs/Promises/Promisifying.md",sourceDirName:"Promises",slug:"/Promises/Promisifying",permalink:"/anantblog/Promises/Promisifying",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Promises",permalink:"/anantblog/Promises/"},next:{title:"Code Snippets",permalink:"/anantblog/category/code-snippets"}},s={},c=[],u={toc:c};function p(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"\u201cPromisification\u201d is a long word for a simple transformation. It\u2019s the conversion of a function that accepts a callback into a function that returns a promise."),(0,a.kt)("p",null,"Such transformations are often required in real-life, as many functions and libraries are callback-based. But promises are more convenient, so it makes sense to promisify them."),(0,a.kt)("p",null,"For better understanding, let\u2019s see an example."),(0,a.kt)("p",null,"For instance, we have loadScript(src, callback) from the chapter Introduction: callbacks."),(0,a.kt)("p",null,"function loadScript(src, callback) {\nlet script = document.createElement('script');\nscript.src = src;"),(0,a.kt)("p",null,"  script.onload = () => callback(null, script);\nscript.onerror = () => callback(new Error(",(0,a.kt)("inlineCode",{parentName:"p"},"Script load error for ${src}"),"));"),(0,a.kt)("p",null,"  document.head.append(script);\n}"),(0,a.kt)("p",null,"// usage:\n// loadScript('path/script.js', (err, script) => {...})\nThe function loads a script with the given src, and then calls callback(err) in case of an error, or callback(null, script) in case of successful loading. That\u2019s a widespread agreement for using callbacks, we saw it before."),(0,a.kt)("p",null,"Let\u2019s promisify it."),(0,a.kt)("p",null,"We\u2019ll make a new function loadScriptPromise(src), that does the same (loads the script), but returns a promise instead of using callbacks."),(0,a.kt)("p",null,"In other words, we pass it only src (no callback) and get a promise in return, that resolves with script when the load is successful, and rejects with the error otherwise."),(0,a.kt)("p",null,"Here it is:"),(0,a.kt)("p",null,"let loadScriptPromise = function(src) {\nreturn new Promise((resolve, reject) => {\nloadScript(src, (err, script) => {\nif (err) reject(err);\nelse resolve(script);\n});\n});\n};"),(0,a.kt)("p",null,"// usage:\n// loadScriptPromise('path/script.js').then(...)\nAs we can see, the new function is a wrapper around the original loadScript function. It calls it providing its own callback that translates to promise resolve/reject."),(0,a.kt)("p",null,"Now loadScriptPromise fits well in promise-based code. If we like promises more than callbacks (and soon we\u2019ll see more reasons for that), then we will use it instead."),(0,a.kt)("p",null,"In practice we may need to promisify more than one function, so it makes sense to use a helper."),(0,a.kt)("p",null,"We\u2019ll call it promisify(f): it accepts a to-promisify function f and returns a wrapper function."),(0,a.kt)("p",null,"function promisify(f) {\nreturn function (...args) { // return a wrapper-function (*)\nreturn new Promise((resolve, reject) => {\nfunction callback(err, result) { // our custom callback for f (**)\nif (err) {\nreject(err);\n} else {\nresolve(result);\n}\n}"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"  args.push(callback); // append our custom callback to the end of f arguments\n\n  f.call(this, ...args); // call the original function\n});\n")),(0,a.kt)("p",null,"  };\n}"),(0,a.kt)("p",null,"// usage:\nlet loadScriptPromise = promisify(loadScript);\nloadScriptPromise(...).then(...);\nThe code may look a bit complex, but it\u2019s essentially the same that we wrote above, while promisifying"),(0,a.kt)("p",null,"loadScript function."),(0,a.kt)("p",null,"A call to promisify(f) returns a wrapper around f (*). That wrapper returns a promise and forwards the call to the original f, tracking the result in the custom callback (**)."),(0,a.kt)("p",null,"Here, promisify assumes that the original function expects a callback with exactly two arguments (err, result). That\u2019s what we encounter most often. Then our custom callback is in exactly the right format, and promisify works great for such a case."),(0,a.kt)("p",null,"But what if the original f expects a callback with more arguments callback(err, res1, res2, ...)?"),(0,a.kt)("p",null,"We can improve our helper. Let\u2019s make a more advanced version of promisify."),(0,a.kt)("p",null,"When called as promisify(f) it should work similar to the version above.\nWhen called as promisify(f, true), it should return the promise that resolves with the array of callback results. That\u2019s exactly for callbacks with many arguments.\n// promisify(f, true) to get array of results\nfunction promisify(f, manyArgs = false) {\nreturn function (...args) {\nreturn new Promise((resolve, reject) => {\nfunction callback(err, ...results) { // our custom callback for f\nif (err) {\nreject(err);\n} else {\n// resolve with all callback results if manyArgs is specified\nresolve(manyArgs ? results : results","[0]",");\n}\n}"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"  args.push(callback);\n\n  f.call(this, ...args);\n});\n")),(0,a.kt)("p",null,"  };\n}"),(0,a.kt)("p",null,"// usage:\nf = promisify(f, true);\nf(...).then(arrayOfResults => ..., err => ...);\nAs you can see it\u2019s essentially the same as above, but resolve is called with only one or all arguments depending on whether manyArgs is truthy."),(0,a.kt)("p",null,"For more exotic callback formats, like those without err at all: callback(result), we can promisify such functions manually without using the helper."),(0,a.kt)("p",null,"There are also modules with a bit more flexible promisification functions, e.g. es6-promisify. In Node.js, there\u2019s a built-in util.promisify function for that."),(0,a.kt)("p",null,"Please note:\nPromisification is a great approach, especially when you use async/await (covered later in the chapter Async/await), but not a total replacement for callbacks."),(0,a.kt)("p",null,"Remember, a promise may have only one result, but a callback may technically be called many times."),(0,a.kt)("p",null,"So promisification is only meant for functions that call the callback once. Further calls will be ignored."))}p.isMDXComponent=!0}}]);