"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[625],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),h=u(n),m=a,w=h["".concat(l,".").concat(m)]||h[m]||p[m]||s;return n?r.createElement(w,o(o({ref:t},c),{},{components:n})):r.createElement(w,o({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var u=2;u<s;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6564:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const s={},o=void 0,i={unversionedId:"Promises/Async await",id:"Promises/Async await",title:"Async await",description:"There\u2019s a special syntax to work with promises in a more comfortable fashion, called \u201casync/await\u201d. It\u2019s surprisingly easy to understand and use.",source:"@site/docs/Promises/Async await.md",sourceDirName:"Promises",slug:"/Promises/Async await",permalink:"/anantblog/Promises/Async await",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Promises",permalink:"/anantblog/category/promises"},next:{title:"Callbacks",permalink:"/anantblog/Promises/Callbacks"}},l={},u=[],c={toc:u};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"There\u2019s a special syntax to work with promises in a more comfortable fashion, called \u201casync/await\u201d. It\u2019s surprisingly easy to understand and use."),(0,a.kt)("p",null,"Async functions\nLet\u2019s start with the async keyword. It can be placed before a function, like this:"),(0,a.kt)("p",null,"async function f() {\nreturn 1;\n}\nThe word \u201casync\u201d before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically."),(0,a.kt)("p",null,"For instance, this function returns a resolved promise with the result of 1; let\u2019s test it:"),(0,a.kt)("p",null,"async function f() {\nreturn 1;\n}"),(0,a.kt)("p",null,"f().then(alert); // 1\n\u2026We could explicitly return a promise, which would be the same:"),(0,a.kt)("p",null,"async function f() {\nreturn Promise.resolve(1);\n}"),(0,a.kt)("p",null,"f().then(alert); // 1\nSo, async ensures that the function returns a promise, and wraps non-promises in it. Simple enough, right? But not only that. There\u2019s another keyword, await, that works only inside async functions, and it\u2019s pretty cool."),(0,a.kt)("p",null,"Await\nThe syntax:"),(0,a.kt)("p",null,"// works only inside async functions\nlet value = await promise;\nThe keyword await makes JavaScript wait until that promise settles and returns its result."),(0,a.kt)("p",null,"Here\u2019s an example with a promise that resolves in 1 second:"),(0,a.kt)("p",null,"async function f() {"),(0,a.kt)("p",null,'  let promise = new Promise((resolve, reject) => {\nsetTimeout(() => resolve("done!"), 1000)\n});'),(0,a.kt)("p",null,"  let result = await promise; // wait until the promise resolves (*)"),(0,a.kt)("p",null,'  alert(result); // "done!"\n}'),(0,a.kt)("p",null,"f();\nThe function execution \u201cpauses\u201d at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows \u201cdone!\u201d in one second."),(0,a.kt)("p",null,"Let\u2019s emphasize: await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn\u2019t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc."),(0,a.kt)("p",null,"It\u2019s just a more elegant syntax of getting the promise result than promise.then. And, it\u2019s easier to read and write."),(0,a.kt)("p",null,"Can\u2019t use await in regular functions\nIf we try to use await in a non-async function, there would be a syntax error:"),(0,a.kt)("p",null,"function f() {\nlet promise = Promise.resolve(1);\nlet result = await promise; // Syntax error\n}\nWe may get this error if we forget to put async before a function. As stated earlier, await only works inside an async function."),(0,a.kt)("p",null,"Let\u2019s take the showAvatar() example from the chapter Promises chaining and rewrite it using async/await:"),(0,a.kt)("p",null,"We\u2019ll need to replace .then calls with await.\nAlso we should make the function async for them to work.\nasync function showAvatar() {"),(0,a.kt)("p",null,"  // read our JSON\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();"),(0,a.kt)("p",null,"  // read github user\nlet githubResponse = await fetch(",(0,a.kt)("inlineCode",{parentName:"p"},"https://api.github.com/users/${user.name}"),");\nlet githubUser = await githubResponse.json();"),(0,a.kt)("p",null,"  // show the avatar\nlet img = document.createElement('img');\nimg.src = githubUser.avatar_url;\nimg.className = \"promise-avatar-example\";\ndocument.body.append(img);"),(0,a.kt)("p",null,"  // wait 3 seconds\nawait new Promise((resolve, reject) => setTimeout(resolve, 3000));"),(0,a.kt)("p",null,"  img.remove();"),(0,a.kt)("p",null,"  return githubUser;\n}"),(0,a.kt)("p",null,"showAvatar();\nPretty clean and easy to read, right? Much better than before."),(0,a.kt)("p",null,"Modern browsers allow top-level await in modules\nIn modern browsers, await on top level works just fine, when we\u2019re inside a module. We\u2019ll cover modules in article Modules, introduction."),(0,a.kt)("p",null,"For instance:"),(0,a.kt)("p",null,"// we assume this code runs at top level, inside a module\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();"),(0,a.kt)("p",null,"console.log(user);\nIf we\u2019re not using modules, or older browsers must be supported, there\u2019s a universal recipe: wrapping into an anonymous async function."),(0,a.kt)("p",null,"Like this:"),(0,a.kt)("p",null,"(async () => {\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n...\n})();\nawait accepts \u201cthenables\u201d\nLike promise.then, await allows us to use thenable objects (those with a callable then method). The idea is that a third-party object may not be a promise, but promise-compatible: if it supports .then, that\u2019s enough to use it with await."),(0,a.kt)("p",null,"Here\u2019s a demo Thenable class; the await below accepts its instances:"),(0,a.kt)("p",null,"class Thenable {\nconstructor(num) {\nthis.num = num;\n}\nthen(resolve, reject) {\nalert(resolve);\n// resolve with this.num",(0,a.kt)("em",{parentName:"p"},"2 after 1000ms\nsetTimeout(() => resolve(this.num ")," 2), 1000); // (*)\n}\n}"),(0,a.kt)("p",null,"async function f() {\n// waits for 1 second, then result becomes 2\nlet result = await new Thenable(1);\nalert(result);\n}"),(0,a.kt)("p",null,"f();\nIf await gets a non-promise object with .then, it calls that method providing the built-in functions resolve and reject as arguments (just as it does for a regular Promise executor). Then await waits until one of them is called (in the example above it happens in the line (*)) and then proceeds with the result."),(0,a.kt)("p",null,"Async class methods\nTo declare an async class method, just prepend it with async:"),(0,a.kt)("p",null,"class Waiter {\nasync wait() {\nreturn await Promise.resolve(1);\n}\n}"),(0,a.kt)("p",null,"new Waiter()\n.wait()\n.then(alert); // 1 (this is the same as (result => alert(result)))\nThe meaning is the same: it ensures that the returned value is a promise and enables await."),(0,a.kt)("p",null,"Error handling\nIf a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line."),(0,a.kt)("p",null,"This code:"),(0,a.kt)("p",null,'async function f() {\nawait Promise.reject(new Error("Whoops!"));\n}\n\u2026is the same as this:'),(0,a.kt)("p",null,'async function f() {\nthrow new Error("Whoops!");\n}\nIn real situations, the promise may take some time before it rejects. In that case there will be a delay before await throws an error.'),(0,a.kt)("p",null,"We can catch that error using try..catch, the same way as a regular throw:"),(0,a.kt)("p",null,"async function f() {"),(0,a.kt)("p",null,"  try {\nlet response = await fetch('http://no-such-url');\n} catch(err) {\nalert(err); // TypeError: failed to fetch\n}\n}"),(0,a.kt)("p",null,"f();\nIn the case of an error, the control jumps to the catch block. We can also wrap multiple lines:"),(0,a.kt)("p",null,"async function f() {"),(0,a.kt)("p",null,"  try {\nlet response = await fetch('/no-user-here');\nlet user = await response.json();\n} catch(err) {\n// catches errors both in fetch and response.json\nalert(err);\n}\n}\nf();\nIf we don\u2019t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:"),(0,a.kt)("p",null,"async function f() {\nlet response = await fetch('http://no-such-url');\n}"),(0,a.kt)("p",null,"// f() becomes a rejected promise\nf().catch(alert); // TypeError: failed to fetch // (*)\nIf we forget to add .catch there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global unhandledrejection event handler as described in the chapter Error handling with promises."),(0,a.kt)("p",null,"async/await and promise.then/catch\nWhen we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That\u2019s usually (but not always) more convenient."),(0,a.kt)("p",null,"But at the top level of the code, when we\u2019re outside any async function, we\u2019re syntactically unable to use await, so it\u2019s a normal practice to add .then/catch to handle the final result or falling-through error, like in the line (*) of the example above."),(0,a.kt)("p",null,"async/await works well with Promise.all\nWhen we need to wait for multiple promises, we can wrap them in Promise.all and then await:"),(0,a.kt)("p",null,"// wait for the array of results\nlet results = await Promise.all(","[\nfetch(url1),\nfetch(url2),\n...\n]",");\nIn the case of an error, it propagates as usual, from the failed promise to Promise.all, and then becomes an exception that we can catch using try..catch around the call."),(0,a.kt)("p",null,"Summary\nThe async keyword before a function has two effects:"),(0,a.kt)("p",null,"Makes it always return a promise.\nAllows await to be used in it.\nThe await keyword before a promise makes JavaScript wait until that promise settles, and then:"),(0,a.kt)("p",null,"If it\u2019s an error, an exception is generated \u2014 same as if throw error were called at that very place.\nOtherwise, it returns the result.\nTogether they provide a great framework to write asynchronous code that is easy to both read and write."),(0,a.kt)("p",null,"With async/await we rarely need to write promise.then/catch, but we still shouldn\u2019t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also Promise.all is nice when we are waiting for many tasks simultaneously."),(0,a.kt)("p",null,"Tasks\nRewrite using async/await\nRewrite this example code from the chapter Promises chaining using async/await instead of .then/catch:"),(0,a.kt)("p",null,"function loadJson(url) {\nreturn fetch(url)\n.then(response => {\nif (response.status == 200) {\nreturn response.json();\n} else {\nthrow new Error(response.status);\n}\n});\n}"),(0,a.kt)("p",null,"loadJson('",(0,a.kt)("a",{parentName:"p",href:"https://javascript.info/no-such-user.json'"},"https://javascript.info/no-such-user.json'"),")\n.catch(alert); // Error: 404\nsolution\nThe notes are below the code:"),(0,a.kt)("p",null,"async function loadJson(url) { // (1)\nlet response = await fetch(url); // (2)"),(0,a.kt)("p",null,"  if (response.status == 200) {\nlet json = await response.json(); // (3)\nreturn json;\n}"),(0,a.kt)("p",null,"  throw new Error(response.status);\n}"),(0,a.kt)("p",null,"loadJson('",(0,a.kt)("a",{parentName:"p",href:"https://javascript.info/no-such-user.json'"},"https://javascript.info/no-such-user.json'"),")\n.catch(alert); // Error: 404 (4)"),(0,a.kt)("p",null,'Rewrite "rethrow" with async/await\nBelow you can find the \u201crethrow\u201d example. Rewrite it using async/await instead of .then/catch.'),(0,a.kt)("p",null,"And get rid of the recursion in favour of a loop in demoGithubUser: with async/await that becomes easy to do."),(0,a.kt)("p",null,"class HttpError extends Error {\nconstructor(response) {\nsuper(",(0,a.kt)("inlineCode",{parentName:"p"},"${response.status} for ${response.url}"),");\nthis.name = 'HttpError';\nthis.response = response;\n}\n}"),(0,a.kt)("p",null,"function loadJson(url) {\nreturn fetch(url)\n.then(response => {\nif (response.status == 200) {\nreturn response.json();\n} else {\nthrow new HttpError(response);\n}\n});\n}"),(0,a.kt)("p",null,'// Ask for a user name until github returns a valid user\nfunction demoGithubUser() {\nlet name = prompt("Enter a name?", "iliakan");'),(0,a.kt)("p",null,"  return loadJson(",(0,a.kt)("inlineCode",{parentName:"p"},"https://api.github.com/users/${name}"),")\n.then(user => {\nalert(",(0,a.kt)("inlineCode",{parentName:"p"},"Full name: ${user.name}."),');\nreturn user;\n})\n.catch(err => {\nif (err instanceof HttpError && err.response.status == 404) {\nalert("No such user, please reenter.");\nreturn demoGithubUser();\n} else {\nthrow err;\n}\n});\n}'),(0,a.kt)("p",null,"demoGithubUser();\nsolution\nThere are no tricks here. Just replace .catch with try..catch inside demoGithubUser and add async/await where needed:"),(0,a.kt)("p",null,"class HttpError extends Error {\nconstructor(response) {\nsuper(",(0,a.kt)("inlineCode",{parentName:"p"},"${response.status} for ${response.url}"),");\nthis.name = 'HttpError';\nthis.response = response;\n}\n}"),(0,a.kt)("p",null,"async function loadJson(url) {\nlet response = await fetch(url);\nif (response.status == 200) {\nreturn response.json();\n} else {\nthrow new HttpError(response);\n}\n}"),(0,a.kt)("p",null,"// Ask for a user name until github returns a valid user\nasync function demoGithubUser() {"),(0,a.kt)("p",null,'  let user;\nwhile(true) {\nlet name = prompt("Enter a name?", "iliakan");'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'try {\n  user = await loadJson(`https://api.github.com/users/${name}`);\n  break; // no error, exit loop\n} catch(err) {\n  if (err instanceof HttpError && err.response.status == 404) {\n    // loop continues after the alert\n    alert("No such user, please reenter.");\n  } else {\n    // unknown error, rethrow\n    throw err;\n  }\n}\n')),(0,a.kt)("p",null,"  }"),(0,a.kt)("p",null,"  alert(",(0,a.kt)("inlineCode",{parentName:"p"},"Full name: ${user.name}."),");\nreturn user;\n}"),(0,a.kt)("p",null,"demoGithubUser();"),(0,a.kt)("p",null,"Call async from non-async\nWe have a \u201cregular\u201d function called f. How can you call the async function wait() and use its result inside of f?"),(0,a.kt)("p",null,"async function wait() {\nawait new Promise(resolve => setTimeout(resolve, 1000));"),(0,a.kt)("p",null,"  return 10;\n}"),(0,a.kt)("p",null,'function f() {\n// ...what should you write here?\n// we need to call async wait() and wait to get 10\n// remember, we can\'t use "await"\n}\nP.S. The task is technically very simple, but the question is quite common for developers new to async/await.'),(0,a.kt)("p",null,"solution\nThat\u2019s the case when knowing how it works inside is helpful."),(0,a.kt)("p",null,"Just treat async call as promise and attach .then to it:"),(0,a.kt)("p",null,"async function wait() {\nawait new Promise(resolve => setTimeout(resolve, 1000));"),(0,a.kt)("p",null,"  return 10;\n}"),(0,a.kt)("p",null,"function f() {\n// shows 10 after 1 second\nwait().then(result => alert(result));\n}\nf();"))}p.isMDXComponent=!0}}]);