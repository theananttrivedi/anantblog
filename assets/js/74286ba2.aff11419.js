"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[992],{3905:(e,r,t)=>{t.d(r,{Zo:()=>m,kt:()=>h});var s=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function n(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);r&&(s=s.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,s)}return t}function l(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?n(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function a(e,r){if(null==e)return{};var t,s,o=function(e,r){if(null==e)return{};var t,s,o={},n=Object.keys(e);for(s=0;s<n.length;s++)t=n[s],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(s=0;s<n.length;s++)t=n[s],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=s.createContext({}),u=function(e){var r=s.useContext(i),t=r;return e&&(t="function"==typeof e?e(r):l(l({},r),e)),t},m=function(e){var r=u(e.components);return s.createElement(i.Provider,{value:r},e.children)},c={inlineCode:"code",wrapper:function(e){var r=e.children;return s.createElement(s.Fragment,{},r)}},p=s.forwardRef((function(e,r){var t=e.components,o=e.mdxType,n=e.originalType,i=e.parentName,m=a(e,["components","mdxType","originalType","parentName"]),p=u(t),h=o,f=p["".concat(i,".").concat(h)]||p[h]||c[h]||n;return t?s.createElement(f,l(l({ref:r},m),{},{components:t})):s.createElement(f,l({ref:r},m))}));function h(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var n=t.length,l=new Array(n);l[0]=p;var a={};for(var i in r)hasOwnProperty.call(r,i)&&(a[i]=r[i]);a.originalType=e,a.mdxType="string"==typeof e?e:o,l[1]=a;for(var u=2;u<n;u++)l[u]=t[u];return s.createElement.apply(null,l)}return s.createElement.apply(null,t)}p.displayName="MDXCreateElement"},5468:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>n,metadata:()=>a,toc:()=>u});var s=t(7462),o=(t(7294),t(3905));const n={},l=void 0,a={unversionedId:"Promises/Promise API",id:"Promises/Promise API",title:"Promise API",description:"There are 6 static methods in the Promise class. We\u2019ll quickly cover their use cases here.",source:"@site/docs/Promises/Promise API.md",sourceDirName:"Promises",slug:"/Promises/Promise API",permalink:"/anantblog/Promises/Promise API",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Microtasks",permalink:"/anantblog/Promises/Microtasks"},next:{title:"Promise Chaining",permalink:"/anantblog/Promises/Promise Chaining"}},i={},u=[],m={toc:u};function c(e){let{components:r,...t}=e;return(0,o.kt)("wrapper",(0,s.Z)({},m,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"There are 6 static methods in the Promise class. We\u2019ll quickly cover their use cases here."),(0,o.kt)("p",null,"Promise.all\nLet\u2019s say we want many promises to execute in parallel and wait until all of them are ready."),(0,o.kt)("p",null,"For instance, download several URLs in parallel and process the content once they are all done."),(0,o.kt)("p",null,"That\u2019s what Promise.all is for."),(0,o.kt)("p",null,"The syntax is:"),(0,o.kt)("p",null,"let promise = Promise.all(iterable);\nPromise.all takes an iterable (usually, an array of promises) and returns a new promise."),(0,o.kt)("p",null,"The new promise resolves when all listed promises are resolved, and the array of their results becomes its result."),(0,o.kt)("p",null,"For instance, the Promise.all below settles after 3 seconds, and then its result is an array ","[1, 2, 3]",":"),(0,o.kt)("p",null,"Promise.all(","[\nnew Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\nnew Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\nnew Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3\n]",").then(alert); // 1,2,3 when promises are ready: each promise contributes an array member\nPlease note that the order of the resulting array members is the same as in its source promises. Even though the first promise takes the longest time to resolve, it\u2019s still first in the array of results."),(0,o.kt)("p",null,"A common trick is to map an array of job data into an array of promises, and then wrap that into Promise.all."),(0,o.kt)("p",null,"For instance, if we have an array of URLs, we can fetch them all like this:"),(0,o.kt)("p",null,"let urls = ","[\n'https://api.github.com/users/iliakan',\n'https://api.github.com/users/remy',\n'https://api.github.com/users/jeresig'\n]",";"),(0,o.kt)("p",null,"// map every url to the promise of the fetch\nlet requests = urls.map(url => fetch(url));"),(0,o.kt)("p",null,"// Promise.all waits until all jobs are resolved\nPromise.all(requests)\n.then(responses => responses.forEach(\nresponse => alert(",(0,o.kt)("inlineCode",{parentName:"p"},"${response.url}: ${response.status}"),")\n));\nA bigger example with fetching user information for an array of GitHub users by their names (we could fetch an array of goods by their ids, the logic is identical):"),(0,o.kt)("p",null,"let names = ","['iliakan', 'remy', 'jeresig']",";"),(0,o.kt)("p",null,"let requests = names.map(name => fetch(",(0,o.kt)("inlineCode",{parentName:"p"},"https://api.github.com/users/${name}"),"));"),(0,o.kt)("p",null,"Promise.all(requests)\n.then(responses => {\n// all responses are resolved successfully\nfor(let response of responses) {\nalert(",(0,o.kt)("inlineCode",{parentName:"p"},"${response.url}: ${response.status}"),"); // shows 200 for every url\n}"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"return responses;\n")),(0,o.kt)("p",null,'  })\n// map array of responses into an array of response.json() to read their content\n.then(responses => Promise.all(responses.map(r => r.json())))\n// all JSON answers are parsed: "users" is the array of them\n.then(users => users.forEach(user => alert(user.name)));\nIf any of the promises is rejected, the promise returned by Promise.all immediately rejects with that error.'),(0,o.kt)("p",null,"For instance:"),(0,o.kt)("p",null,"Promise.all(",'[\nnew Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\nnew Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),\nnew Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]',").catch(alert); // Error: Whoops!\nHere the second promise rejects in two seconds. That leads to an immediate rejection of Promise.all, so .catch executes: the rejection error becomes the outcome of the entire Promise.all."),(0,o.kt)("p",null,"In case of an error, other promises are ignored\nIf one promise rejects, Promise.all immediately rejects, completely forgetting about the other ones in the list. Their results are ignored."),(0,o.kt)("p",null,"For example, if there are multiple fetch calls, like in the example above, and one fails, the others will still continue to execute, but Promise.all won\u2019t watch them anymore. They will probably settle, but their results will be ignored."),(0,o.kt)("p",null,"Promise.all does nothing to cancel them, as there\u2019s no concept of \u201ccancellation\u201d in promises. In another chapter we\u2019ll cover AbortController that can help with that, but it\u2019s not a part of the Promise API."),(0,o.kt)("p",null,"Promise.all(iterable) allows non-promise \u201cregular\u201d values in iterable\nNormally, Promise.all(...) accepts an iterable (in most cases an array) of promises. But if any of those objects is not a promise, it\u2019s passed to the resulting array \u201cas is\u201d."),(0,o.kt)("p",null,"For instance, here the results are ","[1, 2, 3]",":"),(0,o.kt)("p",null,"Promise.all(","[\nnew Promise((resolve, reject) => {\nsetTimeout(() => resolve(1), 1000)\n}),\n2,\n3\n]",").then(alert); // 1, 2, 3\nSo we are able to pass ready values to Promise.all where convenient."),(0,o.kt)("p",null,"Promise.allSettled\nA recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\nPromise.all rejects as a whole if any promise rejects. That\u2019s good for \u201call or nothing\u201d cases, when we need all results successful to proceed:"),(0,o.kt)("p",null,"Promise.all(","[\nfetch('/template.html'),\nfetch('/style.css'),\nfetch('/data.json')\n]",").then(render); // render method needs results of all fetches\nPromise.allSettled just waits for all promises to settle, regardless of the result. The resulting array has:"),(0,o.kt)("p",null,'{status:"fulfilled", value:result} for successful responses,\n{status:"rejected", reason:error} for errors.\nFor example, we\u2019d like to fetch the information about multiple users. Even if one request fails, we\u2019re still interested in the others.'),(0,o.kt)("p",null,"Let\u2019s use Promise.allSettled:"),(0,o.kt)("p",null,"let urls = ","[\n'https://api.github.com/users/iliakan',\n'https://api.github.com/users/remy',\n'https://no-such-url'\n]",";"),(0,o.kt)("p",null,"Promise.allSettled(urls.map(url => fetch(url)))\n.then(results => { // (",(0,o.kt)("em",{parentName:"p"},')\nresults.forEach((result, num) => {\nif (result.status == "fulfilled") {\nalert(',(0,o.kt)("inlineCode",{parentName:"em"},"${urls[num]}: ${result.value.status}"),');\n}\nif (result.status == "rejected") {\nalert(',(0,o.kt)("inlineCode",{parentName:"em"},"${urls[num]}: ${result.reason}"),");\n}\n});\n});\nThe results in the line ("),") above will be:"),(0,o.kt)("p",null,"[\n{status: 'fulfilled', value: ...response...},\n{status: 'fulfilled', value: ...response...},\n{status: 'rejected', reason: ...error object...}\n]","\nSo for each promise we get its status and value/error."),(0,o.kt)("p",null,"Polyfill\nIf the browser doesn\u2019t support Promise.allSettled, it\u2019s easy to polyfill:"),(0,o.kt)("p",null,"if (!Promise.allSettled) {\nconst rejectHandler = reason => ({ status: 'rejected', reason });"),(0,o.kt)("p",null,"  const resolveHandler = value => ({ status: 'fulfilled', value });"),(0,o.kt)("p",null,"  Promise.allSettled = function (promises) {\nconst convertedPromises = promises.map(p => Promise.resolve(p).then(resolveHandler, rejectHandler));\nreturn Promise.all(convertedPromises);\n};\n}\nIn this code, promises.map takes input values, turns them into promises (just in case a non-promise was passed) with p => Promise.resolve(p), and then adds .then handler to every one."),(0,o.kt)("p",null,"That handler turns a successful result value into {status:'fulfilled', value}, and an error reason into {status:'rejected', reason}. That\u2019s exactly the format of Promise.allSettled."),(0,o.kt)("p",null,"Now we can use Promise.allSettled to get the results of all given promises, even if some of them reject."),(0,o.kt)("p",null,"Promise.race\nSimilar to Promise.all, but waits only for the first settled promise and gets its result (or error)."),(0,o.kt)("p",null,"The syntax is:"),(0,o.kt)("p",null,"let promise = Promise.race(iterable);\nFor instance, here the result will be 1:"),(0,o.kt)("p",null,"Promise.race(",'[\nnew Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\nnew Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),\nnew Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]',").then(alert); // 1\nThe first promise here was fastest, so it became the result. After the first settled promise \u201cwins the race\u201d, all further results/errors are ignored."),(0,o.kt)("p",null,"Promise.any\nSimilar to Promise.race, but waits only for the first fulfilled promise and gets its result. If all of the given promises are rejected, then the returned promise is rejected with AggregateError \u2013 a special error object that stores all promise errors in its errors property."),(0,o.kt)("p",null,"The syntax is:\nlet promise = Promise.any(iterable);\nFor instance, here the result will be 1:"),(0,o.kt)("p",null,"Promise.any(",'[\nnew Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),\nnew Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),\nnew Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]',").then(alert); // 1\nThe first promise here was fastest, but it was rejected, so the second promise became the result. After the first fulfilled promise \u201cwins the race\u201d, all further results are ignored."),(0,o.kt)("p",null,"Here\u2019s an example when all promises fail:"),(0,o.kt)("p",null,"Promise.any(",'[\nnew Promise((resolve, reject) => setTimeout(() => reject(new Error("Ouch!")), 1000)),\nnew Promise((resolve, reject) => setTimeout(() => reject(new Error("Error!")), 2000))\n]',").catch(error => {\nconsole.log(error.constructor.name); // AggregateError\nconsole.log(error.errors","[0]","); // Error: Ouch!\nconsole.log(error.errors","[1]","); // Error: Error!\n});\nAs you can see, error objects for failed promises are available in the errors property of the AggregateError object."),(0,o.kt)("p",null,"Promise.resolve/reject\nMethods Promise.resolve and Promise.reject are rarely needed in modern code, because async/await syntax (we\u2019ll cover it a bit later) makes them somewhat obsolete."),(0,o.kt)("p",null,"We cover them here for completeness and for those who can\u2019t use async/await for some reason."),(0,o.kt)("p",null,"Promise.resolve\nPromise.resolve(value) creates a resolved promise with the result value."),(0,o.kt)("p",null,"Same as:"),(0,o.kt)("p",null,"let promise = new Promise(resolve => resolve(value));\nThe method is used for compatibility, when a function is expected to return a promise."),(0,o.kt)("p",null,"For example, the loadCached function below fetches a URL and remembers (caches) its content. For future calls with the same URL it immediately gets the previous content from cache, but uses Promise.resolve to make a promise of it, so the returned value is always a promise:"),(0,o.kt)("p",null,"let cache = new Map();"),(0,o.kt)("p",null,"function loadCached(url) {\nif (cache.has(url)) {\nreturn Promise.resolve(cache.get(url)); // (*)\n}"),(0,o.kt)("p",null,"  return fetch(url)\n.then(response => response.text())\n.then(text => {\ncache.set(url,text);\nreturn text;\n});\n}\nWe can write loadCached(url).then(\u2026), because the function is guaranteed to return a promise. We can always use .then after loadCached. That\u2019s the purpose of Promise.resolve in the line (*)."),(0,o.kt)("p",null,"Promise.reject\nPromise.reject(error) creates a rejected promise with error."),(0,o.kt)("p",null,"Same as:"),(0,o.kt)("p",null,"let promise = new Promise((resolve, reject) => reject(error));\nIn practice, this method is almost never used."),(0,o.kt)("p",null,"Summary\nThere are 6 static methods of Promise class:"),(0,o.kt)("p",null,'Promise.all(promises) \u2013 waits for all promises to resolve and returns an array of their results. If any of the given promises rejects, it becomes the error of Promise.all, and all other results are ignored.\nPromise.allSettled(promises) (recently added method) \u2013 waits for all promises to settle and returns their results as an array of objects with:\nstatus: "fulfilled" or "rejected"\nvalue (if fulfilled) or reason (if rejected).\nPromise.race(promises) \u2013 waits for the first promise to settle, and its result/error becomes the outcome.\nPromise.any(promises) (recently added method) \u2013 waits for the first promise to fulfill, and its result becomes the outcome. If all of the given promises are rejected, AggregateError becomes the error of Promise.any.\nPromise.resolve(value) \u2013 makes a resolved promise with the given value.\nPromise.reject(error) \u2013 makes a rejected promise with the given error.\nOf all these, Promise.all is probably the most common in practice.'))}c.isMDXComponent=!0}}]);